<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta name="description" content="Gate.ioäº¤æ˜“æ‰€Goåç«¯é¢è¯•å®Œæ•´æŒ‡å—ï¼ŒåŒ…å«å¹¶å‘ç¼–ç¨‹ã€æ’®åˆå¼•æ“ã€åŒºå—é“¾æŠ€æœ¯ç­‰æ ¸å¿ƒçŸ¥è¯†ç‚¹">
    <meta name="keywords" content="Go,é¢è¯•,äº¤æ˜“æ‰€,åŒºå—é“¾,æ’®åˆå¼•æ“,å¹¶å‘ç¼–ç¨‹">
    <title>Gate.io äº¤æ˜“æ‰€ Go åç«¯é¢è¯•å®Œæ•´æŒ‡å—</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f7fa;
            overflow-x: hidden;
        }

        .container {
            display: flex;
            max-width: 1400px;
            margin: 0 auto;
        }

        /* ä¾§è¾¹æ  */
        .sidebar {
            width: 280px;
            background: #2c3e50;
            color: white;
            height: 100vh;
            position: fixed;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 20px;
            -webkit-overflow-scrolling: touch;
            transition: transform 0.3s ease;
            z-index: 1000;
        }

        /* æ¡Œé¢ç«¯é»˜è®¤æ˜¾ç¤ºï¼Œä½†å¯ä»¥éšè— */
        @media (min-width: 969px) {
            .sidebar {
                transform: translateX(0);
            }
            
            .sidebar.hide {
                transform: translateX(-100%);
            }
            
            .main-content {
                transition: margin-left 0.3s ease;
            }
            
            .sidebar.hide ~ .main-content {
                margin-left: 0;
            }
        }

        /* ä¾§è¾¹æ æ»šåŠ¨æ¡æ ·å¼ */
        .sidebar::-webkit-scrollbar {
            width: 6px;
        }

        .sidebar::-webkit-scrollbar-track {
            background: #34495e;
        }

        .sidebar::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 3px;
        }

        .sidebar::-webkit-scrollbar-thumb:hover {
            background: #666;
        }

        .sidebar h2 {
            color: #3498db;
            margin-bottom: 20px;
            font-size: 20px;
        }

        .sidebar ul {
            list-style: none;
        }

        .sidebar ul li {
            margin-bottom: 8px;
        }

        .sidebar ul li a {
            color: #ecf0f1;
            text-decoration: none;
            display: block;
            padding: 10px 12px;
            border-radius: 4px;
            transition: all 0.3s;
            font-size: 14px;
            min-height: 44px;
            display: flex;
            align-items: center;
        }

        .sidebar ul li a:hover {
            background: #34495e;
            color: #3498db;
        }

        .sidebar ul ul {
            margin-left: 15px;
            margin-top: 5px;
        }

        .sidebar ul ul li a {
            font-size: 13px;
            color: #bdc3c7;
        }

        /* ä¸»å†…å®¹åŒº */
        .main-content {
            margin-left: 280px;
            padding: 40px;
            flex: 1;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            border-radius: 10px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 32px;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 16px;
            opacity: 0.9;
        }

        .section {
            background: white;
            padding: 30px;
            margin-bottom: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }

        .section h2 {
            color: #2c3e50;
            font-size: 28px;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #3498db;
        }

        .section h3 {
            color: #34495e;
            font-size: 22px;
            margin-top: 30px;
            margin-bottom: 15px;
        }

        .section h4 {
            color: #555;
            font-size: 18px;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .section p {
            margin-bottom: 15px;
            color: #555;
        }

        .section ul, .section ol {
            margin-left: 25px;
            margin-bottom: 15px;
        }

        .section li {
            margin-bottom: 8px;
            color: #555;
        }

        /* ä»£ç å— */
        pre {
            background: #1e1e1e;
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto;
            overflow-y: hidden;
            margin: 20px 0;
            position: relative;
            -webkit-overflow-scrolling: touch;
            max-width: 100%;
        }

        pre code {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 13px;
            line-height: 1.5;
            display: block;
            white-space: pre;
            word-wrap: normal;
            word-break: normal;
        }

        .code-header {
            background: #2d2d2d;
            padding: 10px 20px;
            border-radius: 8px 8px 0 0;
            color: #aaa;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .copy-btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 5px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.3s;
        }

        .copy-btn:hover {
            background: #2980b9;
        }

        /* æ ‡ç­¾ */
        .tag {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            margin-right: 8px;
            margin-bottom: 8px;
        }

        .tag-required {
            background: #e74c3c;
            color: white;
        }

        .tag-important {
            background: #f39c12;
            color: white;
        }

        .tag-advanced {
            background: #9b59b6;
            color: white;
        }

        /* æç¤ºæ¡† */
        .tip-box {
            padding: 15px 20px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid;
        }

        .tip-box.info {
            background: #e8f4fd;
            border-color: #3498db;
            color: #2c5f7f;
        }

        .tip-box.warning {
            background: #fff3cd;
            border-color: #f39c12;
            color: #856404;
        }

        .tip-box.success {
            background: #d4edda;
            border-color: #27ae60;
            color: #155724;
        }

        .tip-box strong {
            display: block;
            margin-bottom: 5px;
        }

        /* è¡¨æ ¼ */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        table th {
            background: #3498db;
            color: white;
            padding: 12px;
            text-align: left;
        }

        table td {
            padding: 12px;
            border-bottom: 1px solid #ddd;
        }

        table tr:hover {
            background: #f8f9fa;
        }

        /* å›åˆ°é¡¶éƒ¨ */
        .back-to-top {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: #3498db;
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transition: all 0.3s;
            opacity: 0;
            pointer-events: none;
        }

        .back-to-top.show {
            opacity: 1;
            pointer-events: auto;
        }

        .back-to-top:hover {
            background: #2980b9;
            transform: translateY(-3px);
        }

        /* æ±‰å ¡èœå•æŒ‰é’® - æ‰€æœ‰è®¾å¤‡éƒ½æ˜¾ç¤º */
        .menu-toggle {
            display: block;
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1001;
            background: #3498db;
            color: white;
            border: none;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            font-size: 24px;
            transition: all 0.3s;
            animation: pulse 2s ease-in-out 3;
        }

        @keyframes pulse {
            0%, 100% {
                box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            }
            50% {
                box-shadow: 0 4px 20px rgba(52, 152, 219, 0.6);
            }
        }

        .menu-toggle:hover {
            background: #2980b9;
            transform: scale(1.05);
            animation: none;
        }

        .menu-toggle:active {
            transform: scale(0.95);
        }

        .menu-toggle.active {
            background: #e74c3c;
            animation: none;
        }

        /* æ¡Œé¢ç«¯æŒ‰é’®ç¨å¾®é€æ˜ */
        @media (min-width: 969px) {
            .menu-toggle {
                opacity: 0.8;
            }
            
            .menu-toggle:hover {
                opacity: 1;
            }
        }

        /* ç§»åŠ¨ç«¯é®ç½© */
        .sidebar-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 999;
        }

        .sidebar-overlay.show {
            display: block;
        }

        /* å“åº”å¼ - å¹³æ¿ */
        @media (max-width: 968px) {
            .menu-toggle {
                opacity: 1 !important; /* ç§»åŠ¨ç«¯å®Œå…¨ä¸é€æ˜ */
            }

            .sidebar {
                transform: translateX(-100%);
                transition: transform 0.3s ease;
                z-index: 1000;
            }

            .sidebar.show {
                transform: translateX(0);
            }

            .main-content {
                margin-left: 0;
                padding: 80px 30px 40px;
            }

            .header h1 {
                font-size: 26px;
            }

            .section h2 {
                font-size: 24px;
            }

            .section h3 {
                font-size: 20px;
            }
        }

        /* å“åº”å¼ - æ‰‹æœº */
        @media (max-width: 640px) {
            body {
                font-size: 14px;
            }

            .sidebar {
                width: 80%;
                max-width: 280px;
            }

            .main-content {
                padding: 70px 15px 30px;
            }

            .header {
                padding: 25px 20px;
                margin-bottom: 20px;
            }

            .header h1 {
                font-size: 22px;
            }

            .header p {
                font-size: 14px;
            }

            .section {
                padding: 20px 15px;
                margin-bottom: 20px;
            }

            .section h2 {
                font-size: 20px;
            }

            .section h3 {
                font-size: 18px;
            }

            .section h4 {
                font-size: 16px;
            }

            /* ä»£ç å—ä¼˜åŒ– */
            pre {
                padding: 15px;
                margin: 15px -15px;
                border-radius: 0;
                font-size: 12px;
            }

            pre code {
                font-size: 12px;
            }

            .code-header {
                padding: 8px 15px;
                margin: 15px -15px 0;
                font-size: 11px;
                border-radius: 0;
            }

            .copy-btn {
                padding: 4px 10px;
                font-size: 10px;
            }

            /* è¡¨æ ¼ä¼˜åŒ– */
            .section table {
                display: block;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                font-size: 13px;
                margin: 15px 0;
            }

            table {
                min-width: auto;
            }

            table th,
            table td {
                padding: 8px;
                white-space: nowrap;
                font-size: 12px;
            }

            /* æ¶æ„å›¾ä¼˜åŒ– */
            .architecture-diagram {
                font-size: 10px;
                padding: 10px;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            /* æç¤ºæ¡†ä¼˜åŒ– */
            .tip-box {
                padding: 12px 15px;
                margin: 15px -15px;
                font-size: 13px;
            }

            /* æ ‡ç­¾ä¼˜åŒ– */
            .tag {
                font-size: 11px;
                padding: 3px 10px;
            }

            /* å›åˆ°é¡¶éƒ¨æŒ‰é’® */
            .back-to-top {
                width: 45px;
                height: 45px;
                bottom: 20px;
                right: 20px;
                font-size: 20px;
            }
        }

        /* æ¨ªå±æ‰‹æœºä¼˜åŒ– */
        @media (max-width: 896px) and (orientation: landscape) {
            .sidebar {
                width: 250px;
            }

            .main-content {
                padding: 60px 20px 30px;
            }
        }

        /* è¶…å°å±å¹• */
        @media (max-width: 375px) {
            .header h1 {
                font-size: 20px;
            }

            .section h2 {
                font-size: 18px;
            }

            .section h3 {
                font-size: 16px;
            }

            pre code {
                font-size: 11px;
            }
        }

        /* æ¶æ„å›¾æ ·å¼ */
        .architecture-diagram {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            font-family: monospace;
            white-space: pre;
            overflow-x: auto;
            margin: 20px 0;
            border: 2px solid #dee2e6;
        }
    </style>
</head>
<body>
    <!-- æ±‰å ¡èœå•æŒ‰é’® -->
    <button class="menu-toggle" id="menuToggle" aria-label="èœå•">
        â˜°
    </button>

    <!-- ä¾§è¾¹æ é®ç½©ï¼ˆç§»åŠ¨ç«¯ç‚¹å‡»å…³é—­èœå•ï¼‰ -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <div class="container">
        <!-- ä¾§è¾¹æ å¯¼èˆª -->
        <nav class="sidebar">
            <h2>ğŸ“š ç›®å½•å¯¼èˆª</h2>
            <ul>
                <li><a href="#intro">ä»‹ç»</a></li>
                <li><a href="#section1">1. Go å¹¶å‘ç¼–ç¨‹</a>
                    <ul>
                        <li><a href="#gmp">GMP è°ƒåº¦æ¨¡å‹</a></li>
                        <li><a href="#channel">Channel å®ç°</a></li>
                        <li><a href="#lock">å¹¶å‘å®‰å…¨ä¸é”</a></li>
                        <li><a href="#context">Context ä½¿ç”¨</a></li>
                    </ul>
                </li>
                <li><a href="#section2">2. äº¤æ˜“æ‰€æ ¸å¿ƒä¸šåŠ¡</a>
                    <ul>
                        <li><a href="#match-engine">æ’®åˆå¼•æ“</a></li>
                        <li><a href="#asset-system">èµ„äº§ç³»ç»Ÿ</a></li>
                        <li><a href="#reconciliation">æµæ°´ä¸å¯¹è´¦</a></li>
                    </ul>
                </li>
                <li><a href="#section3">3. é«˜æ€§èƒ½ç³»ç»Ÿè®¾è®¡</a>
                    <ul>
                        <li><a href="#rate-limiter">é™æµå™¨</a></li>
                        <li><a href="#snowflake">åˆ†å¸ƒå¼ID</a></li>
                    </ul>
                </li>
                <li><a href="#section4">4. åŒºå—é“¾æŠ€æœ¯å®æˆ˜</a>
                    <ul>
                        <li><a href="#wallet">é’±åŒ…åœ°å€ç”Ÿæˆ</a></li>
                        <li><a href="#deposit-watch">å……å€¼ç›‘å¬</a></li>
                    </ul>
                </li>
                <li><a href="#section5">5. ç³»ç»Ÿè®¾è®¡å¤§é¢˜</a>
                    <ul>
                        <li><a href="#trading-system">ç°è´§äº¤æ˜“ç³»ç»Ÿ</a></li>
                        <li><a href="#deposit-withdraw">å……æç³»ç»Ÿ</a></li>
                    </ul>
                </li>
                <li><a href="#section6">6. ç®—æ³•ä¸æ•°æ®ç»“æ„</a>
                    <ul>
                        <li><a href="#lru">LRU Cache</a></li>
                        <li><a href="#consistent-hash">ä¸€è‡´æ€§Hash</a></li>
                    </ul>
                </li>
                <li><a href="#interview">7. é¢è¯•æ¨¡æ‹Ÿ</a></li>
                <li><a href="#summary">8. æ€»ç»“å»ºè®®</a></li>
            </ul>
        </nav>

        <!-- ä¸»å†…å®¹ -->
        <main class="main-content">
            <div class="header" id="intro">
                <h1>ğŸš€ Gate.io äº¤æ˜“æ‰€ Go åç«¯é¢è¯•å®Œæ•´æŒ‡å—</h1>
                <p>ä»åŸºç¡€åˆ°è¿›é˜¶ï¼Œä»åŸç†åˆ°å®æˆ˜ï¼ŒåŠ©ä½ æ‹¿ä¸‹ Offerï¼</p>
            </div>

            <!-- ç¬¬1éƒ¨åˆ†ï¼šGoå¹¶å‘ç¼–ç¨‹ -->
            <section class="section" id="section1">
                <h2>1. Go å¹¶å‘ç¼–ç¨‹æ·±åº¦è§£æ</h2>
                
                <div id="gmp">
                    <h3>1.1 GMP è°ƒåº¦æ¨¡å‹ <span class="tag tag-required">å¿…è€ƒ</span></h3>
                    
                    <div class="tip-box info">
                        <strong>ğŸ’¡ é¢è¯•é—®é¢˜</strong>
                        è¯·è§£é‡Š Go çš„ GMP è°ƒåº¦æ¨¡å‹
                    </div>

                    <h4>æ ‡å‡†å›ç­”ï¼š</h4>
                    <p><strong>GMP æ¨¡å‹åŒ…å«ä¸‰ä¸ªæ ¸å¿ƒç»„ä»¶ï¼š</strong></p>
                    <ul>
                        <li><strong>G (Goroutine)</strong>ï¼šç”¨æˆ·æ€çš„è½»é‡çº§çº¿ç¨‹ï¼ŒåŒ…å«äº†è¦æ‰§è¡Œçš„ä»£ç ã€æ ˆç©ºé—´ã€çŠ¶æ€ä¿¡æ¯</li>
                        <li><strong>M (Machine)</strong>ï¼šæ“ä½œç³»ç»Ÿçº¿ç¨‹ï¼ŒçœŸæ­£æ‰§è¡Œ G çš„å®ä½“</li>
                        <li><strong>P (Processor)</strong>ï¼šè°ƒåº¦å™¨ï¼Œç»´æŠ¤ G çš„æœ¬åœ°é˜Ÿåˆ—ï¼Œè´Ÿè´£ç®¡ç† G çš„æ‰§è¡Œ</li>
                    </ul>

                    <p><strong>æ ¸å¿ƒå·¥ä½œæœºåˆ¶ï¼š</strong></p>
                    <ol>
                        <li>æ¯ä¸ª P ç»´æŠ¤ä¸€ä¸ªæœ¬åœ° G é˜Ÿåˆ—ï¼ˆæœ€å¤š 256 ä¸ªï¼‰</li>
                        <li>å…¨å±€æœ‰ä¸€ä¸ª G é˜Ÿåˆ—ï¼ˆæ— ç•Œï¼‰</li>
                        <li>M éœ€è¦ç»‘å®š P æ‰èƒ½æ‰§è¡Œ G</li>
                        <li><strong>Work Stealing</strong>ï¼šå½“ P çš„æœ¬åœ°é˜Ÿåˆ—ä¸ºç©ºæ—¶ï¼Œä¼šä»å…¶ä»– P æˆ–å…¨å±€é˜Ÿåˆ—å·å– G</li>
                    </ol>

                    <div class="tip-box success">
                        <strong>âœ… ä¼˜åŠ¿</strong>
                        <ul>
                            <li>å‡å°‘é”ç«äº‰ï¼ˆæœ¬åœ°é˜Ÿåˆ—æ— é”è®¿é—®ï¼‰</li>
                            <li>å……åˆ†åˆ©ç”¨å¤šæ ¸ CPU</li>
                            <li>æŠ¢å å¼è°ƒåº¦ï¼ˆé˜²æ­¢æŸä¸ª G é•¿æœŸå ç”¨ï¼‰</li>
                        </ul>
                    </div>

                    <h4>ä»£ç ç¤ºä¾‹ï¼š</h4>
                    <div class="code-header">
                        <span>gmp_demo.go</span>
                        <button class="copy-btn" onclick="copyCode(this)">å¤åˆ¶</button>
                    </div>
                    <pre><code class="language-go">package main

import (
    "fmt"
    "runtime"
    "sync"
    "time"
)

// æ¼”ç¤º GOMAXPROCS çš„å½±å“
func DemoGMP() {
    // è®¾ç½® P çš„æ•°é‡ä¸º 2
    runtime.GOMAXPROCS(2)
    
    var wg sync.WaitGroup
    
    // å¯åŠ¨ 10 ä¸ª goroutine
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            // CPU å¯†é›†å‹ä»»åŠ¡
            sum := 0
            for j := 0; j < 1e8; j++ {
                sum += j
            }
            fmt.Printf("Goroutine %d å®Œæˆ\n", id)
        }(i)
    }
    
    wg.Wait()
    fmt.Printf("å½“å‰ Goroutine æ•°é‡: %d\n", runtime.NumGoroutine())
}

// æ¼”ç¤º Goroutine æ³„æ¼
func BadGoroutineExample() {
    ch := make(chan int)
    
    // è¿™ä¸ª goroutine ä¼šæ°¸è¿œé˜»å¡ï¼Œé€ æˆæ³„æ¼
    go func() {
        val := <-ch // æ°¸è¿œç­‰å¾…
        fmt.Println(val)
    }()
    
    // å¿˜è®°å‘ channel å‘é€æ•°æ®
    time.Sleep(time.Second)
}

// æ­£ç¡®çš„åšæ³•ï¼šä½¿ç”¨ context æ§åˆ¶
func GoodGoroutineExample() {
    ctx, cancel := context.WithTimeout(context.Background(), time.Second)
    defer cancel()
    
    ch := make(chan int)
    
    go func() {
        select {
        case val := <-ch:
            fmt.Println(val)
        case <-ctx.Done():
            fmt.Println("è¶…æ—¶ï¼Œgoroutine é€€å‡º")
            return
        }
    }()
    
    time.Sleep(2 * time.Second) // æ¨¡æ‹Ÿè¶…æ—¶
}

func main() {
    DemoGMP()
}</code></pre>

                    <div class="tip-box warning">
                        <strong>âš ï¸ å¦‚ä½•æ’æŸ¥ Goroutine æ³„æ¼ï¼Ÿ</strong>
                        <ol>
                            <li>ä½¿ç”¨ <code>runtime.NumGoroutine()</code> ç›‘æ§æ•°é‡</li>
                            <li>ä½¿ç”¨ pprof æŸ¥çœ‹ goroutine å †æ ˆï¼š<code>http://localhost:6060/debug/pprof/goroutine</code></li>
                            <li>ä½¿ç”¨ <code>runtime.Stack()</code> æ‰“å°æ‰€æœ‰ goroutine</li>
                        </ol>
                    </div>
                </div>

                <div id="channel">
                    <h3>1.2 Channel å®ç°åŸç† <span class="tag tag-required">å¿…è€ƒ</span></h3>
                    
                    <div class="tip-box info">
                        <strong>ğŸ’¡ é¢è¯•é—®é¢˜</strong>
                        Channel çš„åº•å±‚å®ç°æ˜¯ä»€ä¹ˆï¼Ÿæœ‰ç¼“å†²å’Œæ— ç¼“å†²çš„åŒºåˆ«ï¼Ÿ
                    </div>

                    <h4>åº•å±‚ç»“æ„ï¼š</h4>
                    <pre><code class="language-go">type hchan struct {
    qcount   uint           // å½“å‰é˜Ÿåˆ—ä¸­çš„å…ƒç´ ä¸ªæ•°
    dataqsiz uint           // ç¯å½¢é˜Ÿåˆ—çš„å¤§å°
    buf      unsafe.Pointer // æŒ‡å‘ç¯å½¢é˜Ÿåˆ—çš„æŒ‡é’ˆ
    elemsize uint16         // å…ƒç´ å¤§å°
    closed   uint32         // æ˜¯å¦å…³é—­
    sendx    uint           // å‘é€ç´¢å¼•
    recvx    uint           // æ¥æ”¶ç´¢å¼•
    recvq    waitq          // æ¥æ”¶ç­‰å¾…é˜Ÿåˆ—ï¼ˆé˜»å¡çš„ goroutineï¼‰
    sendq    waitq          // å‘é€ç­‰å¾…é˜Ÿåˆ—
    lock     mutex          // äº’æ–¥é”
}</code></pre>

                    <h4>å…³é”®åŒºåˆ«ï¼š</h4>
                    <table>
                        <tr>
                            <th>ç‰¹æ€§</th>
                            <th>æ— ç¼“å†² Channel</th>
                            <th>æœ‰ç¼“å†² Channel</th>
                        </tr>
                        <tr>
                            <td>åˆ›å»º</td>
                            <td><code>make(chan int)</code></td>
                            <td><code>make(chan int, 10)</code></td>
                        </tr>
                        <tr>
                            <td>å‘é€</td>
                            <td>å¿…é¡»æœ‰æ¥æ”¶è€…æ‰èƒ½å®Œæˆ</td>
                            <td>ç¼“å†²æœªæ»¡æ—¶ä¸é˜»å¡</td>
                        </tr>
                        <tr>
                            <td>æ¥æ”¶</td>
                            <td>å¿…é¡»æœ‰å‘é€è€…æ‰èƒ½å®Œæˆ</td>
                            <td>ç¼“å†²éç©ºæ—¶ä¸é˜»å¡</td>
                        </tr>
                        <tr>
                            <td>åŒæ­¥æ€§</td>
                            <td>åŒæ­¥æ“ä½œ</td>
                            <td>å¼‚æ­¥æ“ä½œ</td>
                        </tr>
                    </table>

                    <h4>ä»£ç ç¤ºä¾‹ï¼š</h4>
                    <div class="code-header">
                        <span>channel_demo.go</span>
                        <button class="copy-btn" onclick="copyCode(this)">å¤åˆ¶</button>
                    </div>
                    <pre><code class="language-go">package main

import (
    "fmt"
    "time"
)

// æ— ç¼“å†² channelï¼šå¿…é¡»åŒæ­¥
func UnbufferedChannelDemo() {
    ch := make(chan int)
    
    // å¦‚æœæ²¡æœ‰æ¥æ”¶è€…ï¼Œè¿™é‡Œä¼šæ°¸ä¹…é˜»å¡
    go func() {
        fmt.Println("å‘é€å‰")
        ch <- 1 // é˜»å¡ï¼Œç›´åˆ°æœ‰äººæ¥æ”¶
        fmt.Println("å‘é€å")
    }()
    
    time.Sleep(time.Second) // æ¨¡æ‹Ÿå»¶è¿Ÿ
    fmt.Println("æ¥æ”¶å‰")
    val := <-ch // æ­¤æ—¶ä¸Šé¢çš„å‘é€æ‰èƒ½å®Œæˆ
    fmt.Println("æ¥æ”¶åˆ°:", val)
}

// æœ‰ç¼“å†² channelï¼šå¼‚æ­¥
func BufferedChannelDemo() {
    ch := make(chan int, 3) // ç¼“å†²åŒºå¤§å°ä¸º 3
    
    // å‘é€ 3 ä¸ªä¸ä¼šé˜»å¡
    ch <- 1
    ch <- 2
    ch <- 3
    fmt.Println("å‘é€å®Œæˆï¼Œæœªé˜»å¡")
    
    // å‘é€ç¬¬ 4 ä¸ªä¼šé˜»å¡
    go func() {
        fmt.Println("å‘é€ç¬¬4ä¸ª...")
        ch <- 4 // é˜»å¡ï¼Œç›´åˆ°æœ‰äººæ¥æ”¶
        fmt.Println("ç¬¬4ä¸ªå‘é€æˆåŠŸ")
    }()
    
    time.Sleep(time.Second)
    <-ch // æ¥æ”¶ä¸€ä¸ªï¼Œé‡Šæ”¾ä¸€ä¸ªä½ç½®
}

// Select å¤šè·¯å¤ç”¨
func SelectDemo() {
    ch1 := make(chan string)
    ch2 := make(chan string)
    
    go func() {
        time.Sleep(time.Second)
        ch1 <- "from ch1"
    }()
    
    go func() {
        time.Sleep(2 * time.Second)
        ch2 <- "from ch2"
    }()
    
    // è°å…ˆå‡†å¤‡å¥½å°±æ¥æ”¶è°
    for i := 0; i < 2; i++ {
        select {
        case msg1 := <-ch1:
            fmt.Println(msg1)
        case msg2 := <-ch2:
            fmt.Println(msg2)
        case <-time.After(3 * time.Second):
            fmt.Println("è¶…æ—¶")
            return
        }
    }
}</code></pre>

                    <div class="tip-box warning">
                        <strong>âš ï¸ Channel ä½¿ç”¨æ³¨æ„äº‹é¡¹</strong>
                        <ul>
                            <li>å‘å·²å…³é—­çš„ channel å‘é€ä¼š panic</li>
                            <li>ä»å·²å…³é—­çš„ channel æ¥æ”¶ä¼šç«‹å³è¿”å›é›¶å€¼</li>
                            <li>å…³é—­ä¸€ä¸ª nil channel ä¼š panic</li>
                            <li>å…³é—­ channel åº”è¯¥ç”±å‘é€æ–¹è´Ÿè´£</li>
                        </ul>
                    </div>
                </div>

                <div id="lock">
                    <h3>1.3 å¹¶å‘å®‰å…¨ä¸é” <span class="tag tag-important">é‡è¦</span></h3>
                    
                    <div class="tip-box info">
                        <strong>ğŸ’¡ é¢è¯•é—®é¢˜</strong>
                        å®ç°ä¸€ä¸ªå¹¶å‘å®‰å…¨çš„è®¡æ•°å™¨ï¼Œæœ‰å“ªäº›æ–¹æ¡ˆï¼Ÿ
                    </div>

                    <h4>ä¸‰ç§å®ç°æ–¹æ¡ˆï¼š</h4>
                    <div class="code-header">
                        <span>concurrent_counter.go</span>
                        <button class="copy-btn" onclick="copyCode(this)">å¤åˆ¶</button>
                    </div>
                    <pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "sync/atomic"
    "time"
)

// æ–¹æ¡ˆ1ï¼šMutexï¼ˆäº’æ–¥é”ï¼‰
type CounterMutex struct {
    mu    sync.Mutex
    count int64
}

func (c *CounterMutex) Inc() {
    c.mu.Lock()
    c.count++
    c.mu.Unlock()
}

func (c *CounterMutex) Get() int64 {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.count
}

// æ–¹æ¡ˆ2ï¼šRWMutexï¼ˆè¯»å†™é”ï¼‰- é€‚åˆè¯»å¤šå†™å°‘
type CounterRWMutex struct {
    mu    sync.RWMutex
    count int64
}

func (c *CounterRWMutex) Inc() {
    c.mu.Lock()
    c.count++
    c.mu.Unlock()
}

func (c *CounterRWMutex) Get() int64 {
    c.mu.RLock() // è¯»é”ï¼Œå…è®¸å¤šä¸ªè¯»è€…
    defer c.mu.RUnlock()
    return c.count
}

// æ–¹æ¡ˆ3ï¼šAtomicï¼ˆåŸå­æ“ä½œï¼‰- æ€§èƒ½æœ€å¥½
type CounterAtomic struct {
    count int64
}

func (c *CounterAtomic) Inc() {
    atomic.AddInt64(&c.count, 1)
}

func (c *CounterAtomic) Get() int64 {
    return atomic.LoadInt64(&c.count)
}

// æ€§èƒ½æµ‹è¯•
func BenchmarkCounters() {
    const goroutines = 1000
    const increments = 10000
    
    // æµ‹è¯• Mutex
    var wg sync.WaitGroup
    counter1 := &CounterMutex{}
    start := time.Now()
    for i := 0; i < goroutines; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for j := 0; j < increments; j++ {
                counter1.Inc()
            }
        }()
    }
    wg.Wait()
    fmt.Printf("Mutex: %v, value=%d\n", time.Since(start), counter1.Get())
    
    // æµ‹è¯• Atomic
    counter2 := &CounterAtomic{}
    start = time.Now()
    for i := 0; i < goroutines; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for j := 0; j < increments; j++ {
                counter2.Inc()
            }
        }()
    }
    wg.Wait()
    fmt.Printf("Atomic: %v, value=%d\n", time.Since(start), counter2.Get())
}

func main() {
    BenchmarkCounters()
}</code></pre>

                    <h4>æ€§èƒ½å¯¹æ¯”ï¼š</h4>
                    <table>
                        <tr>
                            <th>æ–¹æ¡ˆ</th>
                            <th>æ€§èƒ½</th>
                            <th>é€‚ç”¨åœºæ™¯</th>
                        </tr>
                        <tr>
                            <td>Atomic</td>
                            <td>â­â­â­â­â­</td>
                            <td>ç®€å•çš„åŸå­æ“ä½œï¼ˆåŠ å‡ã€äº¤æ¢ï¼‰</td>
                        </tr>
                        <tr>
                            <td>RWMutex</td>
                            <td>â­â­â­â­</td>
                            <td>è¯»å¤šå†™å°‘çš„åœºæ™¯</td>
                        </tr>
                        <tr>
                            <td>Mutex</td>
                            <td>â­â­â­</td>
                            <td>å¤æ‚çš„ä¸´ç•ŒåŒºæ“ä½œ</td>
                        </tr>
                    </table>
                </div>

                <div id="context">
                    <h3>1.4 Context ä½¿ç”¨ï¼ˆè¶…æ—¶æ§åˆ¶ï¼‰<span class="tag tag-important">é‡è¦</span></h3>
                    
                    <h4>äº¤æ˜“æ‰€å®æˆ˜ï¼šè®¢å•è¶…æ—¶å–æ¶ˆ</h4>
                    <div class="code-header">
                        <span>context_order.go</span>
                        <button class="copy-btn" onclick="copyCode(this)">å¤åˆ¶</button>
                    </div>
                    <pre><code class="language-go">package main

import (
    "context"
    "fmt"
    "time"
)

type Order struct {
    ID     string
    Status string
}

// ä¸‹å•å¹¶è®¾ç½®è¶…æ—¶
func PlaceOrder(ctx context.Context, order *Order) error {
    // è®¢å•åŒ¹é…ï¼Œå‡è®¾éœ€è¦ 500ms
    matchDone := make(chan bool)
    
    go func() {
        time.Sleep(500 * time.Millisecond)
        matchDone <- true
    }()
    
    select {
    case <-matchDone:
        order.Status = "matched"
        return nil
    case <-ctx.Done():
        order.Status = "timeout"
        return ctx.Err()
    }
}

func main() {
    // è®¾ç½® 300ms è¶…æ—¶
    ctx, cancel := context.WithTimeout(context.Background(), 300*time.Millisecond)
    defer cancel()
    
    order := &Order{ID: "ORD001", Status: "pending"}
    err := PlaceOrder(ctx, order)
    
    if err != nil {
        fmt.Printf("è®¢å• %s è¶…æ—¶: %v\n", order.ID, err)
    } else {
        fmt.Printf("è®¢å• %s æˆäº¤\n", order.ID)
    }
}</code></pre>
                </div>
            </section>

            <!-- ç¬¬2éƒ¨åˆ†ï¼šäº¤æ˜“æ‰€æ ¸å¿ƒä¸šåŠ¡ -->
            <section class="section" id="section2">
                <h2>2. äº¤æ˜“æ‰€æ ¸å¿ƒä¸šåŠ¡å®ç°</h2>
                
                <div id="match-engine">
                    <h3>2.1 è®¢å•æ’®åˆå¼•æ“ <span class="tag tag-required">æ ¸å¿ƒå¿…è€ƒ</span></h3>
                    
                    <div class="tip-box info">
                        <strong>ğŸ’¡ é¢è¯•é—®é¢˜</strong>
                        å®ç°ä¸€ä¸ªç®€å•çš„é™ä»·å•æ’®åˆå¼•æ“
                    </div>

                    <h4>æ ¸å¿ƒè®¾è®¡æ€è·¯ï¼š</h4>
                    <ul>
                        <li><strong>è®¢å•ç°¿</strong>ï¼šç”¨ä¸¤ä¸ª map å­˜å‚¨ä¹°å–ç›˜ï¼Œæ¯ä¸ªä»·æ ¼ä¸€ä¸ªé“¾è¡¨</li>
                        <li><strong>ä»·æ ¼æ’åº</strong>ï¼šä¹°å•é™åºï¼ˆä»·é«˜ä¼˜å…ˆï¼‰ï¼Œå–å•å‡åºï¼ˆä»·ä½ä¼˜å…ˆï¼‰</li>
                        <li><strong>æ’®åˆåŸåˆ™</strong>ï¼šä»·æ ¼ä¼˜å…ˆã€æ—¶é—´ä¼˜å…ˆ</li>
                        <li><strong>å¹¶å‘å®‰å…¨</strong>ï¼šä½¿ç”¨è¯»å†™é”ä¿æŠ¤</li>
                    </ul>

                    <div class="tip-box success">
                        <strong>âœ… å…³é”®ç‚¹</strong>
                        <ul>
                            <li>å¸‚ä»·å•åƒæ‰å¯¹æ‰‹ç›˜æœ€ä¼˜ä»·æ ¼</li>
                            <li>é™ä»·å•åªåŒ¹é…æ»¡è¶³ä»·æ ¼æ¡ä»¶çš„è®¢å•</li>
                            <li>æˆäº¤ä»·æ ¼æ˜¯æŒ‚å•ä»·æ ¼ï¼ˆMaker ä»·æ ¼ï¼‰</li>
                        </ul>
                    </div>

                    <div class="code-header">
                        <span>match_engine.goï¼ˆå®Œæ•´å®ç°ï¼‰</span>
                        <button class="copy-btn" onclick="copyCode(this)">å¤åˆ¶</button>
                    </div>
                    <pre><code class="language-go">package main

import (
    "container/list"
    "fmt"
    "sync"
    "time"
)

// ============ è®¢å•ç±»å‹å®šä¹‰ ============
type OrderSide string
const (
    BUY  OrderSide = "BUY"
    SELL OrderSide = "SELL"
)

type OrderType string
const (
    LIMIT  OrderType = "LIMIT"
    MARKET OrderType = "MARKET"
)

// è®¢å•ç»“æ„
type Order struct {
    ID        string
    UserID    string
    Side      OrderSide
    Type      OrderType
    Price     float64
    Quantity  float64
    Filled    float64
    Status    string
    CreatedAt time.Time
}

// æˆäº¤è®°å½•
type Trade struct {
    ID          string
    BuyOrderID  string
    SellOrderID string
    Price       float64
    Quantity    float64
    Timestamp   time.Time
}

// ============ ä»·æ ¼æ¡£ä½ ============
type PriceLevel struct {
    Price  float64
    Orders *list.List
    Volume float64
}

// ============ è®¢å•ç°¿ ============
type OrderBook struct {
    Symbol    string
    Bids      map[float64]*PriceLevel
    BidPrices []float64
    Asks      map[float64]*PriceLevel
    AskPrices []float64
    mu        sync.RWMutex
}

func NewOrderBook(symbol string) *OrderBook {
    return &OrderBook{
        Symbol:    symbol,
        Bids:      make(map[float64]*PriceLevel),
        Asks:      make(map[float64]*PriceLevel),
        BidPrices: []float64{},
        AskPrices: []float64{},
    }
}

// æ·»åŠ è®¢å•åˆ°è®¢å•ç°¿
func (ob *OrderBook) AddOrder(order *Order) {
    ob.mu.Lock()
    defer ob.mu.Unlock()
    
    var levels map[float64]*PriceLevel
    var prices *[]float64
    
    if order.Side == BUY {
        levels = ob.Bids
        prices = &ob.BidPrices
    } else {
        levels = ob.Asks
        prices = &ob.AskPrices
    }
    
    level, exists := levels[order.Price]
    if !exists {
        level = &PriceLevel{
            Price:  order.Price,
            Orders: list.New(),
            Volume: 0,
        }
        levels[order.Price] = level
        *prices = insertPrice(*prices, order.Price, order.Side == BUY)
    }
    
    level.Orders.PushBack(order)
    level.Volume += order.Quantity - order.Filled
}

// æ’å…¥ä»·æ ¼å¹¶ä¿æŒæ’åº
func insertPrice(prices []float64, price float64, descending bool) []float64 {
    i := 0
    for i < len(prices) {
        if descending {
            if price > prices[i] {
                break
            }
        } else {
            if price < prices[i] {
                break
            }
        }
        i++
    }
    
    prices = append(prices, 0)
    copy(prices[i+1:], prices[i:])
    prices[i] = price
    return prices
}

// ============ æ’®åˆå¼•æ“ ============
type MatchEngine struct {
    OrderBook *OrderBook
    Trades    []Trade
    mu        sync.Mutex
}

func NewMatchEngine(symbol string) *MatchEngine {
    return &MatchEngine{
        OrderBook: NewOrderBook(symbol),
        Trades:    []Trade{},
    }
}

// æ’®åˆè®¢å•
func (me *MatchEngine) MatchOrder(order *Order) []Trade {
    me.mu.Lock()
    defer me.mu.Unlock()
    
    var trades []Trade
    
    if order.Type == LIMIT {
        trades = me.matchLimitOrder(order)
    } else {
        trades = me.matchMarketOrder(order)
    }
    
    // æœªå®Œå…¨æˆäº¤çš„é™ä»·å•åŠ å…¥è®¢å•ç°¿
    if order.Filled < order.Quantity && order.Type == LIMIT {
        if order.Filled > 0 {
            order.Status = "partial"
        }
        me.OrderBook.AddOrder(order)
    }
    
    me.Trades = append(me.Trades, trades...)
    return trades
}

// æ’®åˆé™ä»·å•
func (me *MatchEngine) matchLimitOrder(order *Order) []Trade {
    trades := []Trade{}
    
    var oppositeLevels map[float64]*PriceLevel
    var oppositePrices []float64
    
    if order.Side == BUY {
        oppositeLevels = me.OrderBook.Asks
        oppositePrices = me.OrderBook.AskPrices
    } else {
        oppositeLevels = me.OrderBook.Bids
        oppositePrices = me.OrderBook.BidPrices
    }
    
    for len(oppositePrices) > 0 {
        bestPrice := oppositePrices[0]
        
        // æ£€æŸ¥ä»·æ ¼æ˜¯å¦åŒ¹é…
        if order.Side == BUY && bestPrice > order.Price {
            break
        }
        if order.Side == SELL && bestPrice < order.Price {
            break
        }
        
        level := oppositeLevels[bestPrice]
        
        for level.Orders.Len() > 0 {
            element := level.Orders.Front()
            makerOrder := element.Value.(*Order)
            
            // è®¡ç®—æˆäº¤é‡
            matchQty := minFloat(order.Quantity-order.Filled, 
                                makerOrder.Quantity-makerOrder.Filled)
            
            // åˆ›å»ºæˆäº¤è®°å½•
            trade := Trade{
                ID:        fmt.Sprintf("T%d", time.Now().UnixNano()),
                Price:     bestPrice,
                Quantity:  matchQty,
                Timestamp: time.Now(),
            }
            
            if order.Side == BUY {
                trade.BuyOrderID = order.ID
                trade.SellOrderID = makerOrder.ID
            } else {
                trade.BuyOrderID = makerOrder.ID
                trade.SellOrderID = order.ID
            }
            
            trades = append(trades, trade)
            
            // æ›´æ–°è®¢å•
            order.Filled += matchQty
            makerOrder.Filled += matchQty
            level.Volume -= matchQty
            
            if makerOrder.Filled >= makerOrder.Quantity {
                makerOrder.Status = "filled"
                level.Orders.Remove(element)
            }
            
            if order.Filled >= order.Quantity {
                order.Status = "filled"
                return trades
            }
        }
        
        if level.Orders.Len() == 0 {
            delete(oppositeLevels, bestPrice)
            oppositePrices = oppositePrices[1:]
            if order.Side == BUY {
                me.OrderBook.AskPrices = oppositePrices
            } else {
                me.OrderBook.BidPrices = oppositePrices
            }
        }
    }
    
    return trades
}

// æ’®åˆå¸‚ä»·å•
func (me *MatchEngine) matchMarketOrder(order *Order) []Trade {
    trades := []Trade{}
    
    var oppositeLevels map[float64]*PriceLevel
    var oppositePrices []float64
    
    if order.Side == BUY {
        oppositeLevels = me.OrderBook.Asks
        oppositePrices = me.OrderBook.AskPrices
    } else {
        oppositeLevels = me.OrderBook.Bids
        oppositePrices = me.OrderBook.BidPrices
    }
    
    for len(oppositePrices) > 0 && order.Filled < order.Quantity {
        bestPrice := oppositePrices[0]
        level := oppositeLevels[bestPrice]
        
        for level.Orders.Len() > 0 && order.Filled < order.Quantity {
            element := level.Orders.Front()
            makerOrder := element.Value.(*Order)
            
            matchQty := minFloat(order.Quantity-order.Filled,
                               makerOrder.Quantity-makerOrder.Filled)
            
            trade := Trade{
                ID:        fmt.Sprintf("T%d", time.Now().UnixNano()),
                Price:     bestPrice,
                Quantity:  matchQty,
                Timestamp: time.Now(),
            }
            
            if order.Side == BUY {
                trade.BuyOrderID = order.ID
                trade.SellOrderID = makerOrder.ID
            } else {
                trade.BuyOrderID = makerOrder.ID
                trade.SellOrderID = order.ID
            }
            
            trades = append(trades, trade)
            order.Filled += matchQty
            makerOrder.Filled += matchQty
            level.Volume -= matchQty
            
            if makerOrder.Filled >= makerOrder.Quantity {
                makerOrder.Status = "filled"
                level.Orders.Remove(element)
            }
        }
        
        if level.Orders.Len() == 0 {
            delete(oppositeLevels, bestPrice)
            oppositePrices = oppositePrices[1:]
        }
    }
    
    if order.Filled >= order.Quantity {
        order.Status = "filled"
    } else {
        order.Status = "partial"
    }
    
    return trades
}

func minFloat(a, b float64) float64 {
    if a < b {
        return a
    }
    return b
}

// ============ æµ‹è¯• ============
func TestMatchEngine() {
    engine := NewMatchEngine("BTC/USDT")
    
    fmt.Println("=== æ·»åŠ å–å• ===")
    sell1 := &Order{
        ID: "S1", UserID: "user1", Side: SELL, Type: LIMIT,
        Price: 50000, Quantity: 1.0, Status: "pending",
        CreatedAt: time.Now(),
    }
    sell2 := &Order{
        ID: "S2", UserID: "user2", Side: SELL, Type: LIMIT,
        Price: 50100, Quantity: 0.5, Status: "pending",
        CreatedAt: time.Now(),
    }
    engine.OrderBook.AddOrder(sell1)
    engine.OrderBook.AddOrder(sell2)
    
    fmt.Println("=== ä¹°å•æ’®åˆ ===")
    buy1 := &Order{
        ID: "B1", UserID: "user3", Side: BUY, Type: LIMIT,
        Price: 50000, Quantity: 0.8, Status: "pending",
        CreatedAt: time.Now(),
    }
    
    trades := engine.MatchOrder(buy1)
    
    fmt.Printf("æˆäº¤è®°å½•æ•°: %d\n", len(trades))
    for _, trade := range trades {
        fmt.Printf("ä»·æ ¼: %.2f, æ•°é‡: %.2f, ä¹°å•: %s, å–å•: %s\n",
            trade.Price, trade.Quantity, trade.BuyOrderID, trade.SellOrderID)
    }
    
    fmt.Printf("\nä¹°å•çŠ¶æ€: %s, å·²æˆäº¤: %.2f/%.2f\n",
        buy1.Status, buy1.Filled, buy1.Quantity)
}

func main() {
    TestMatchEngine()
}</code></pre>
                </div>

                <div id="asset-system">
                    <h3>2.2 èµ„äº§ç³»ç»Ÿï¼ˆè´¦æˆ·ä½™é¢ç®¡ç†ï¼‰<span class="tag tag-required">å¿…è€ƒ</span></h3>
                    
                    <div class="tip-box info">
                        <strong>ğŸ’¡ é¢è¯•é—®é¢˜</strong>
                        å¦‚ä½•ä¿è¯äº¤æ˜“æ‰€è´¦æˆ·ä½™é¢çš„ä¸€è‡´æ€§ï¼Ÿ
                    </div>

                    <h4>æ ¸å¿ƒè®¾è®¡ï¼šåŒè´¦æˆ·æ¨¡å‹</h4>
                    <ul>
                        <li><strong>å¯ç”¨ä½™é¢</strong>ï¼šç”¨æˆ·å¯ä»¥ä½¿ç”¨çš„éƒ¨åˆ†</li>
                        <li><strong>å†»ç»“ä½™é¢</strong>ï¼šä¸‹å•åå†»ç»“ï¼Œç­‰å¾…æˆäº¤</li>
                        <li><strong>æ€»ä½™é¢</strong> = å¯ç”¨ + å†»ç»“</li>
                    </ul>

                    <h4>ä¸šåŠ¡æµç¨‹ï¼š</h4>
                    <ol>
                        <li><strong>ä¸‹å•</strong>ï¼šå†»ç»“ç›¸åº”é‡‘é¢</li>
                        <li><strong>æˆäº¤</strong>ï¼šæ‰£é™¤å†»ç»“ï¼Œå¯¹æ–¹å¢åŠ å¯ç”¨</li>
                        <li><strong>æ’¤å•</strong>ï¼šè§£å†»æœªæˆäº¤éƒ¨åˆ†</li>
                        <li><strong>æµæ°´</strong>ï¼šè®°å½•æ¯ä¸€æ­¥å˜åŠ¨</li>
                    </ol>

                    <div class="code-header">
                        <span>asset_system.go</span>
                        <button class="copy-btn" onclick="copyCode(this)">å¤åˆ¶</button>
                    </div>
                    <pre><code class="language-go">type Balance struct {
    Currency  string
    Available float64 // å¯ç”¨
    Frozen    float64 // å†»ç»“
}

type Account struct {
    UserID   string
    Balances map[string]*Balance
    mu       sync.RWMutex
}

// å†»ç»“ä½™é¢ï¼ˆä¸‹å•æ—¶ï¼‰
func (a *Account) Freeze(currency string, amount float64) error {
    a.mu.Lock()
    defer a.mu.Unlock()
    
    balance := a.Balances[currency]
    if balance.Available < amount {
        return errors.New("ä½™é¢ä¸è¶³")
    }
    
    balance.Available -= amount
    balance.Frozen += amount
    return nil
}

// æ‰£é™¤å†»ç»“ï¼ˆæˆäº¤æ—¶ï¼‰
func (a *Account) DeductFrozen(currency string, amount float64) error {
    a.mu.Lock()
    defer a.mu.Unlock()
    
    balance := a.Balances[currency]
    if balance.Frozen < amount {
        return errors.New("å†»ç»“ä½™é¢ä¸è¶³")
    }
    
    balance.Frozen -= amount
    return nil
}

// å¢åŠ å¯ç”¨ï¼ˆæˆäº¤æ”¶åˆ°èµ„äº§ï¼‰
func (a *Account) AddAvailable(currency string, amount float64) {
    a.mu.Lock()
    defer a.mu.Unlock()
    
    balance := a.Balances[currency]
    balance.Available += amount
}</code></pre>

                    <div class="tip-box warning">
                        <strong>âš ï¸ å¯¹è´¦æœºåˆ¶</strong>
                        <ul>
                            <li>å®šæ—¶æ£€æŸ¥ï¼šå¯ç”¨ + å†»ç»“ = æ€»èµ„äº§</li>
                            <li>æµæ°´å¯¹è´¦ï¼šæ ¹æ®æµæ°´è¡¨é‡æ–°è®¡ç®—ä½™é¢</li>
                            <li>å‘Šè­¦æœºåˆ¶ï¼šå‘ç°ä¸ä¸€è‡´ç«‹å³å‘Šè­¦</li>
                        </ul>
                    </div>
                </div>

                <div id="reconciliation">
                    <h3>2.3 æµæ°´è¡¨è®¾è®¡ä¸å¯¹è´¦ <span class="tag tag-important">é‡è¦</span></h3>
                    
                    <div class="tip-box info">
                        <strong>ğŸ’¡ æ ¸å¿ƒæ€æƒ³</strong>
                        è®°å½•æ¯ä¸€ç¬”èµ„äº§å˜åŠ¨ï¼Œç”¨äºå®¡è®¡å’Œå¯¹è´¦
                    </div>

                    <h4>æµæ°´è¡¨è®¾è®¡ï¼š</h4>
                    <div class="code-header">
                        <span>transaction_log.go</span>
                        <button class="copy-btn" onclick="copyCode(this)">å¤åˆ¶</button>
                    </div>
                    <pre><code class="language-go">// æµæ°´ç±»å‹
type TransactionType string

const (
    DEPOSIT    TransactionType = "DEPOSIT"    // å……å€¼
    WITHDRAW   TransactionType = "WITHDRAW"   // æç°
    TRADE_BUY  TransactionType = "TRADE_BUY"  // ä¹°å…¥æˆäº¤
    TRADE_SELL TransactionType = "TRADE_SELL" // å–å‡ºæˆäº¤
    FEE        TransactionType = "FEE"        // æ‰‹ç»­è´¹
    FREEZE     TransactionType = "FREEZE"     // å†»ç»“
    UNFREEZE   TransactionType = "UNFREEZE"   // è§£å†»
)

// æµæ°´è®°å½•
type Transaction struct {
    ID            string
    UserID        string
    AccountType   AccountType
    Currency      string
    Type          TransactionType
    Amount        float64         // å˜åŠ¨é‡‘é¢ï¼ˆæ­£æ•°ä¸ºå¢åŠ ï¼Œè´Ÿæ•°ä¸ºå‡å°‘ï¼‰
    BalanceBefore float64         // å˜åŠ¨å‰ä½™é¢
    BalanceAfter  float64         // å˜åŠ¨åä½™é¢
    RefID         string          // å…³è”IDï¼ˆè®¢å•IDã€äº¤æ˜“IDç­‰ï¼‰
    Timestamp     time.Time
    Remark        string
}

// å¯¹è´¦é€»è¾‘
type ReconciliationService struct {
    db *sql.DB
}

func (s *ReconciliationService) ReconcileAccount(
    userID, currency string,
) error {
    // 1. è·å–å½“å‰è´¦æˆ·ä½™é¢
    var available, frozen float64
    err := s.db.QueryRow(`
        SELECT available, frozen 
        FROM accounts 
        WHERE user_id = ? AND currency = ?
    `, userID, currency).Scan(&available, &frozen)
    
    if err != nil {
        return err
    }
    
    currentTotal := available + frozen
    
    // 2. ä»æµæ°´è¡¨è®¡ç®—ä½™é¢
    var calculatedBalance float64
    err = s.db.QueryRow(`
        SELECT COALESCE(SUM(amount), 0)
        FROM transactions 
        WHERE user_id = ? AND currency = ?
    `, userID, currency).Scan(&calculatedBalance)
    
    if err != nil {
        return err
    }
    
    // 3. å¯¹æ¯”å·®å¼‚
    diff := currentTotal - calculatedBalance
    if math.Abs(diff) > 0.00000001 { // æµ®ç‚¹æ•°æ¯”è¾ƒ
        return fmt.Errorf(
            "ä½™é¢ä¸ä¸€è‡´: è´¦æˆ·=%.8f, æµæ°´=%.8f, å·®å¼‚=%.8f",
            currentTotal, calculatedBalance, diff,
        )
    }
    
    return nil
}

// å®šæ—¶å¯¹è´¦ä»»åŠ¡
func (s *ReconciliationService) DailyReconciliation() {
    ticker := time.NewTicker(24 * time.Hour)
    defer ticker.Stop()
    
    for range ticker.C {
        // è·å–æ‰€æœ‰æ´»è·ƒç”¨æˆ·
        rows, _ := s.db.Query(`
            SELECT DISTINCT user_id, currency 
            FROM accounts 
            WHERE updated_at > DATE_SUB(NOW(), INTERVAL 1 DAY)
        `)
        defer rows.Close()
        
        for rows.Next() {
            var userID, currency string
            rows.Scan(&userID, &currency)
            
            if err := s.ReconcileAccount(userID, currency); err != nil {
                // å‘é€å‘Šè­¦
                log.Printf("å¯¹è´¦å¤±è´¥: %s - %s: %v", userID, currency, err)
                // å¯ä»¥å‘é‚®ä»¶ã€é’‰é’‰é€šçŸ¥ç­‰
            }
        }
    }
}</code></pre>

                    <h4>SQL è¡¨è®¾è®¡ï¼š</h4>
                    <pre><code class="language-sql">-- æµæ°´è¡¨
CREATE TABLE transactions (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id VARCHAR(32) NOT NULL,
    currency VARCHAR(10) NOT NULL,
    type VARCHAR(20) NOT NULL,
    amount DECIMAL(30, 8) NOT NULL,
    balance_before DECIMAL(30, 8) NOT NULL,
    balance_after DECIMAL(30, 8) NOT NULL,
    ref_id VARCHAR(64),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    remark VARCHAR(255),
    INDEX idx_user_currency_time(user_id, currency, created_at),
    INDEX idx_ref_id(ref_id)
) PARTITION BY RANGE(TO_DAYS(created_at));</code></pre>

                    <div class="tip-box warning">
                        <strong>âš ï¸ å¯¹è´¦è¦ç‚¹</strong>
                        <ul>
                            <li><strong>T+0 å¯¹è´¦</strong>ï¼šå®æ—¶æ£€æŸ¥æ¯ç¬”äº¤æ˜“åä½™é¢</li>
                            <li><strong>T+1 å¯¹è´¦</strong>ï¼šæ¯æ—¥å…¨é‡å¯¹è´¦</li>
                            <li><strong>å·®å¼‚å¤„ç†</strong>ï¼šå‘ç°ä¸ä¸€è‡´ç«‹å³å‘Šè­¦ï¼Œäººå·¥ä»‹å…¥</li>
                            <li><strong>æµæ°´ä¸å¯åˆ é™¤</strong>ï¼šåªèƒ½æ ‡è®°ä½œåºŸï¼Œä¿è¯å®¡è®¡å®Œæ•´æ€§</li>
                        </ul>
                    </div>
                </div>
            </section>

            <!-- ç¬¬3éƒ¨åˆ†ï¼šé«˜æ€§èƒ½ç³»ç»Ÿ -->
            <section class="section" id="section3">
                <h2>3. é«˜æ€§èƒ½ç³»ç»Ÿè®¾è®¡</h2>
                
                <div id="rate-limiter">
                    <h3>3.1 é™æµå™¨å®ç° <span class="tag tag-important">é‡è¦</span></h3>
                    
                    <div class="tip-box info">
                        <strong>ğŸ’¡ é¢è¯•é—®é¢˜</strong>
                        å®ç°ä¸€ä¸ªæ”¯æŒ QPS é™åˆ¶çš„ä¸­é—´ä»¶ï¼Œæœ‰å“ªäº›ç®—æ³•ï¼Ÿ
                    </div>

                    <h4>ä¸‰ç§ç®—æ³•å¯¹æ¯”ï¼š</h4>
                    <table>
                        <tr>
                            <th>ç®—æ³•</th>
                            <th>ä¼˜ç‚¹</th>
                            <th>ç¼ºç‚¹</th>
                            <th>é€‚ç”¨åœºæ™¯</th>
                        </tr>
                        <tr>
                            <td>å›ºå®šçª—å£</td>
                            <td>ç®€å•æ˜“æ‡‚</td>
                            <td>è¾¹ç•Œçªåˆºé—®é¢˜</td>
                            <td>ç²—ç•¥é™æµ</td>
                        </tr>
                        <tr>
                            <td>æ»‘åŠ¨çª—å£</td>
                            <td>æ›´ç²¾ç¡®å¹³æ»‘</td>
                            <td>å†…å­˜å ç”¨é«˜</td>
                            <td>ä¸¥æ ¼é™æµ</td>
                        </tr>
                        <tr>
                            <td>ä»¤ç‰Œæ¡¶</td>
                            <td>æ”¯æŒçªå‘æµé‡</td>
                            <td>ç¨å¤æ‚</td>
                            <td>ç”Ÿäº§æ¨èâ­</td>
                        </tr>
                    </table>

                    <h4>å®Œæ•´å®ç°ï¼š</h4>
                    <div class="code-header">
                        <span>rate_limiter.go - ä¸‰ç§ç®—æ³•å®Œæ•´å®ç°</span>
                        <button class="copy-btn" onclick="copyCode(this)">å¤åˆ¶</button>
                    </div>
                    <pre><code class="language-go">package main

import (
    "fmt"
    "net/http"
    "sync"
    "time"
)

// ============ ç®—æ³•1ï¼šå›ºå®šçª—å£è®¡æ•°å™¨ ============
type FixedWindowLimiter struct {
    limit     int
    window    time.Duration
    counter   int
    lastReset time.Time
    mu        sync.Mutex
}

func NewFixedWindowLimiter(limit int, window time.Duration) *FixedWindowLimiter {
    return &FixedWindowLimiter{
        limit:     limit,
        window:    window,
        counter:   0,
        lastReset: time.Now(),
    }
}

func (l *FixedWindowLimiter) Allow() bool {
    l.mu.Lock()
    defer l.mu.Unlock()
    
    now := time.Now()
    
    // çª—å£é‡ç½®
    if now.Sub(l.lastReset) >= l.window {
        l.counter = 0
        l.lastReset = now
    }
    
    if l.counter < l.limit {
        l.counter++
        return true
    }
    
    return false
}

// ============ ç®—æ³•2ï¼šæ»‘åŠ¨çª—å£ ============
type SlidingWindowLimiter struct {
    limit    int
    window   time.Duration
    requests []time.Time
    mu       sync.Mutex
}

func NewSlidingWindowLimiter(limit int, window time.Duration) *SlidingWindowLimiter {
    return &SlidingWindowLimiter{
        limit:    limit,
        window:   window,
        requests: []time.Time{},
    }
}

func (l *SlidingWindowLimiter) Allow() bool {
    l.mu.Lock()
    defer l.mu.Unlock()
    
    now := time.Now()
    windowStart := now.Add(-l.window)
    
    // ç§»é™¤è¿‡æœŸè¯·æ±‚
    validRequests := []time.Time{}
    for _, t := range l.requests {
        if t.After(windowStart) {
            validRequests = append(validRequests, t)
        }
    }
    l.requests = validRequests
    
    // æ£€æŸ¥é™åˆ¶
    if len(l.requests) < l.limit {
        l.requests = append(l.requests, now)
        return true
    }
    
    return false
}

// ============ ç®—æ³•3ï¼šä»¤ç‰Œæ¡¶ï¼ˆæ¨èï¼‰============
type TokenBucketLimiter struct {
    capacity   int           // æ¡¶å®¹é‡
    tokens     int           // å½“å‰ä»¤ç‰Œæ•°
    rate       time.Duration // æ·»åŠ ä»¤ç‰Œçš„é€Ÿç‡
    lastRefill time.Time
    mu         sync.Mutex
}

func NewTokenBucketLimiter(capacity int, rate time.Duration) *TokenBucketLimiter {
    return &TokenBucketLimiter{
        capacity:   capacity,
        tokens:     capacity,
        rate:       rate,
        lastRefill: time.Now(),
    }
}

func (l *TokenBucketLimiter) Allow() bool {
    l.mu.Lock()
    defer l.mu.Unlock()
    
    // è¡¥å……ä»¤ç‰Œ
    now := time.Now()
    elapsed := now.Sub(l.lastRefill)
    tokensToAdd := int(elapsed / l.rate)
    
    if tokensToAdd > 0 {
        l.tokens = min(l.tokens+tokensToAdd, l.capacity)
        l.lastRefill = now
    }
    
    // æ¶ˆè´¹ä»¤ç‰Œ
    if l.tokens > 0 {
        l.tokens--
        return true
    }
    
    return false
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

// ============ HTTP ä¸­é—´ä»¶ç¤ºä¾‹ ============
func RateLimitMiddleware(limiter *TokenBucketLimiter) func(http.HandlerFunc) http.HandlerFunc {
    return func(next http.HandlerFunc) http.HandlerFunc {
        return func(w http.ResponseWriter, r *http.Request) {
            if !limiter.Allow() {
                http.Error(w, "Rate limit exceeded", http.StatusTooManyRequests)
                return
            }
            next(w, r)
        }
    }
}

// ============ æ€§èƒ½æµ‹è¯• ============
func TestRateLimiters() {
    fmt.Println("=== å›ºå®šçª—å£æµ‹è¯• ===")
    fixed := NewFixedWindowLimiter(10, time.Second)
    testLimiter(fixed, "å›ºå®šçª—å£")
    
    fmt.Println("\n=== æ»‘åŠ¨çª—å£æµ‹è¯• ===")
    sliding := NewSlidingWindowLimiter(10, time.Second)
    testLimiter(sliding, "æ»‘åŠ¨çª—å£")
    
    fmt.Println("\n=== ä»¤ç‰Œæ¡¶æµ‹è¯• ===")
    token := NewTokenBucketLimiter(10, 100*time.Millisecond)
    testLimiter(token, "ä»¤ç‰Œæ¡¶")
}

type Limiter interface {
    Allow() bool
}

func testLimiter(limiter Limiter, name string) {
    success := 0
    failed := 0
    
    // å¿«é€Ÿå‘é€20ä¸ªè¯·æ±‚
    for i := 0; i < 20; i++ {
        if limiter.Allow() {
            success++
        } else {
            failed++
        }
        time.Sleep(50 * time.Millisecond)
    }
    
    fmt.Printf("%s: æˆåŠŸ=%d, å¤±è´¥=%d\n", name, success, failed)
}

// ============ äº¤æ˜“æ‰€åº”ç”¨ï¼šAPI é™æµ ============
type ExchangeRateLimiter struct {
    // ä¸åŒæ¥å£ä¸åŒé™åˆ¶
    orderLimiter   *TokenBucketLimiter // ä¸‹å•ï¼š10æ¬¡/ç§’
    queryLimiter   *TokenBucketLimiter // æŸ¥è¯¢ï¼š100æ¬¡/ç§’
    tradeHistory   *TokenBucketLimiter // å†å²ï¼š50æ¬¡/åˆ†é’Ÿ
}

func NewExchangeRateLimiter() *ExchangeRateLimiter {
    return &ExchangeRateLimiter{
        orderLimiter:  NewTokenBucketLimiter(10, 100*time.Millisecond),
        queryLimiter:  NewTokenBucketLimiter(100, 10*time.Millisecond),
        tradeHistory:  NewTokenBucketLimiter(50, time.Minute/50),
    }
}

func (e *ExchangeRateLimiter) AllowOrder() bool {
    return e.orderLimiter.Allow()
}

func (e *ExchangeRateLimiter) AllowQuery() bool {
    return e.queryLimiter.Allow()
}

func (e *ExchangeRateLimiter) AllowTradeHistory() bool {
    return e.tradeHistory.Allow()
}

func main() {
    TestRateLimiters()
    
    // äº¤æ˜“æ‰€é™æµç¤ºä¾‹
    fmt.Println("\n=== äº¤æ˜“æ‰€ API é™æµ ===")
    exchLimiter := NewExchangeRateLimiter()
    
    // æ¨¡æ‹Ÿå¤§é‡ä¸‹å•è¯·æ±‚
    orderSuccess := 0
    for i := 0; i < 20; i++ {
        if exchLimiter.AllowOrder() {
            orderSuccess++
        }
    }
    fmt.Printf("ä¸‹å•è¯·æ±‚ï¼šæˆåŠŸ=%d/20\n", orderSuccess)
}</code></pre>

                    <div class="tip-box warning">
                        <strong>âš ï¸ è¾¹ç•Œé—®é¢˜ï¼šå›ºå®šçª—å£çš„ç¼ºé™·</strong>
                        <p>å‡è®¾é™åˆ¶ 100æ¬¡/åˆ†é’Ÿï¼š</p>
                        <ul>
                            <li>ç¬¬1åˆ†é’Ÿç¬¬59ç§’ï¼šå‘é€100æ¬¡ âœ…</li>
                            <li>ç¬¬2åˆ†é’Ÿç¬¬1ç§’ï¼šåˆå‘é€100æ¬¡ âœ…</li>
                            <li>ç»“æœï¼š2ç§’å†…å‘é€äº†200æ¬¡ï¼Œè¶…å‡ºé¢„æœŸï¼</li>
                        </ul>
                        <p>è§£å†³æ–¹æ¡ˆï¼šä½¿ç”¨æ»‘åŠ¨çª—å£æˆ–ä»¤ç‰Œæ¡¶</p>
                    </div>

                    <div class="tip-box success">
                        <strong>âœ… ç”Ÿäº§ç¯å¢ƒæ¨èï¼šä»¤ç‰Œæ¡¶</strong>
                        <ul>
                            <li>æ”¯æŒçªå‘æµé‡ï¼ˆæ¡¶æ»¡æ—¶å¯ç¬é—´å¤„ç† capacity ä¸ªè¯·æ±‚ï¼‰</li>
                            <li>å¹³æ»‘é™æµï¼ˆæŒ‰å›ºå®šé€Ÿç‡è¡¥å……ä»¤ç‰Œï¼‰</li>
                            <li>é€‚åˆç»å¤§å¤šæ•°åœºæ™¯</li>
                        </ul>
                    </div>
                </div>

                <div id="snowflake">
                    <h3>3.2 åˆ†å¸ƒå¼IDç”Ÿæˆï¼ˆé›ªèŠ±ç®—æ³•ï¼‰<span class="tag tag-important">é‡è¦</span></h3>
                    
                    <h4>IDç»“æ„ï¼ˆ64ä½ï¼‰ï¼š</h4>
                    <pre>1ä½ç¬¦å·ä½ | 41ä½æ—¶é—´æˆ³ | 10ä½æœºå™¨ID | 12ä½åºåˆ—å·</pre>

                    <div class="tip-box success">
                        <strong>âœ… ä¼˜åŠ¿</strong>
                        <ul>
                            <li>è¶‹åŠ¿é€’å¢ï¼ˆæŒ‰æ—¶é—´æ’åºï¼‰</li>
                            <li>é«˜æ€§èƒ½ï¼ˆæ— éœ€ç½‘ç»œè°ƒç”¨ï¼‰</li>
                            <li>å…¨å±€å”¯ä¸€</li>
                        </ul>
                    </div>

                    <div class="code-header">
                        <span>snowflake.go</span>
                        <button class="copy-btn" onclick="copyCode(this)">å¤åˆ¶</button>
                    </div>
                    <pre><code class="language-go">type SnowflakeIDGenerator struct {
    mu            sync.Mutex
    epoch         int64 // èµ·å§‹æ—¶é—´æˆ³
    machineID     int64 // æœºå™¨IDï¼ˆ0-1023ï¼‰
    sequence      int64 // åºåˆ—å·ï¼ˆ0-4095ï¼‰
    lastTimestamp int64
}

func (g *SnowflakeIDGenerator) NextID() (int64, error) {
    g.mu.Lock()
    defer g.mu.Unlock()
    
    timestamp := time.Now().UnixNano() / 1e6
    
    if timestamp < g.lastTimestamp {
        return 0, errors.New("æ—¶é’Ÿå›æ‹¨")
    }
    
    if timestamp == g.lastTimestamp {
        // åŒä¸€æ¯«ç§’ï¼Œåºåˆ—å·+1
        g.sequence = (g.sequence + 1) & maxSequence
        if g.sequence == 0 {
            // åºåˆ—å·æº¢å‡ºï¼Œç­‰å¾…ä¸‹ä¸€æ¯«ç§’
            for timestamp <= g.lastTimestamp {
                timestamp = time.Now().UnixNano() / 1e6
            }
        }
    } else {
        g.sequence = 0
    }
    
    g.lastTimestamp = timestamp
    
    // ç»„åˆID
    id := ((timestamp - g.epoch) << timestampShift) |
          (g.machineID << machineIDShift) |
          g.sequence
    
    return id, nil
}</code></pre>
                </div>
            </section>

            <!-- ç¬¬4éƒ¨åˆ†ï¼šåŒºå—é“¾æŠ€æœ¯ -->
            <section class="section" id="section4">
                <h2>4. åŒºå—é“¾æŠ€æœ¯å®æˆ˜</h2>
                
                <div id="wallet">
                    <h3>4.1 ä»¥å¤ªåŠé’±åŒ…åœ°å€ç”Ÿæˆ <span class="tag tag-important">é‡è¦</span></h3>
                    
                    <div class="tip-box info">
                        <strong>ğŸ’¡ é¢è¯•é—®é¢˜</strong>
                        å¦‚ä½•ç”Ÿæˆä»¥å¤ªåŠåœ°å€ï¼Ÿè¯·è§£é‡Šæ•´ä¸ªæµç¨‹
                    </div>

                    <h4>ç”Ÿæˆæµç¨‹ï¼š</h4>
                    <ol>
                        <li>ç”Ÿæˆ ECDSA ç§é’¥ï¼ˆ256ä½éšæœºæ•°ï¼‰</li>
                        <li>ä»ç§é’¥è®¡ç®—å…¬é’¥ï¼ˆæ¤­åœ†æ›²çº¿ç®—æ³•ï¼‰</li>
                        <li>å¯¹å…¬é’¥è¿›è¡Œ Keccak256 å“ˆå¸Œ</li>
                        <li>å–å“ˆå¸Œç»“æœçš„å 20 å­—èŠ‚ä½œä¸ºåœ°å€</li>
                        <li>æ·»åŠ  "0x" å‰ç¼€ï¼Œå¾—åˆ°ä»¥å¤ªåŠåœ°å€</li>
                    </ol>

                    <div class="code-header">
                        <span>eth_wallet.go</span>
                        <button class="copy-btn" onclick="copyCode(this)">å¤åˆ¶</button>
                    </div>
                    <pre><code class="language-go">package main

import (
    "crypto/ecdsa"
    "crypto/rand"
    "encoding/hex"
    "fmt"
    
    "github.com/ethereum/go-ethereum/crypto"
)

// ç”Ÿæˆä»¥å¤ªåŠåœ°å€
func GenerateEthereumAddress() (address, privateKey, publicKey string, err error) {
    // 1. ç”Ÿæˆ ECDSA ç§é’¥
    key, err := ecdsa.GenerateKey(crypto.S256(), rand.Reader)
    if err != nil {
        return "", "", "", err
    }
    
    // 2. ä»ç§é’¥å¯¼å‡ºå…¬é’¥
    publicKeyECDSA := key.Public().(*ecdsa.PublicKey)
    publicKeyBytes := crypto.FromECDSAPub(publicKeyECDSA)
    
    // 3. è®¡ç®—åœ°å€ï¼ˆå…¬é’¥ Keccak256 çš„å 20 å­—èŠ‚ï¼‰
    addressBytes := crypto.PubkeyToAddress(*publicKeyECDSA)
    
    // 4. ç¼–ç 
    privateKeyBytes := crypto.FromECDSA(key)
    
    return addressBytes.Hex(),
           hex.EncodeToString(privateKeyBytes),
           hex.EncodeToString(publicKeyBytes),
           nil
}

// ä»ç§é’¥æ¢å¤åœ°å€
func GetAddressFromPrivateKey(privateKeyHex string) (string, error) {
    privateKeyBytes, err := hex.DecodeString(privateKeyHex)
    if err != nil {
        return "", err
    }
    
    key, err := crypto.ToECDSA(privateKeyBytes)
    if err != nil {
        return "", err
    }
    
    publicKey := key.Public().(*ecdsa.PublicKey)
    address := crypto.PubkeyToAddress(*publicKey)
    
    return address.Hex(), nil
}

// åœ°å€æ± ç®¡ç†
type AddressPool struct {
    db          *sql.DB
    mu          sync.Mutex
    preGenCount int // é¢„ç”Ÿæˆåœ°å€æ•°é‡
}

func NewAddressPool(db *sql.DB) *AddressPool {
    return &AddressPool{
        db:          db,
        preGenCount: 1000, // é¢„ç”Ÿæˆ1000ä¸ªåœ°å€
    }
}

// åˆå§‹åŒ–ï¼šé¢„ç”Ÿæˆåœ°å€
func (p *AddressPool) Initialize() error {
    for i := 0; i < p.preGenCount; i++ {
        address, privKey, _, err := GenerateEthereumAddress()
        if err != nil {
            return err
        }
        
        // åŠ å¯†ç§é’¥åå­˜å‚¨
        encryptedPrivKey := encrypt(privKey) // å®é™…éœ€è¦åŠ å¯†
        
        _, err = p.db.Exec(`
            INSERT INTO address_pool (address, private_key, currency, status)
            VALUES (?, ?, 'ETH', 'available')
        `, address, encryptedPrivKey)
        
        if err != nil {
            return err
        }
    }
    return nil
}

// åˆ†é…åœ°å€ç»™ç”¨æˆ·
func (p *AddressPool) AllocateAddress(userID, currency string) (string, error) {
    p.mu.Lock()
    defer p.mu.Unlock()
    
    tx, _ := p.db.Begin()
    defer tx.Rollback()
    
    // 1. ä»åœ°å€æ± è·å–ä¸€ä¸ªå¯ç”¨åœ°å€
    var address string
    err := tx.QueryRow(`
        SELECT address FROM address_pool 
        WHERE currency = ? AND status = 'available' 
        LIMIT 1 FOR UPDATE
    `, currency).Scan(&address)
    
    if err != nil {
        return "", errors.New("åœ°å€æ± å·²ç©º")
    }
    
    // 2. æ›´æ–°çŠ¶æ€ä¸ºå·²åˆ†é…
    _, err = tx.Exec(`
        UPDATE address_pool 
        SET status = 'allocated', user_id = ?, allocated_at = NOW()
        WHERE address = ?
    `, userID, address)
    
    if err != nil {
        return "", err
    }
    
    // 3. è®°å½•ç”¨æˆ·åœ°å€
    _, err = tx.Exec(`
        INSERT INTO user_addresses (user_id, currency, address, created_at)
        VALUES (?, ?, ?, NOW())
    `, userID, currency, address)
    
    tx.Commit()
    
    // 4. æ£€æŸ¥åœ°å€æ± ï¼Œä½äºé˜ˆå€¼æ—¶è¡¥å……
    go p.checkAndRefill()
    
    return address, nil
}

// æ£€æŸ¥å¹¶è¡¥å……åœ°å€æ± 
func (p *AddressPool) checkAndRefill() {
    var count int
    p.db.QueryRow(`
        SELECT COUNT(*) FROM address_pool 
        WHERE status = 'available'
    `).Scan(&count)
    
    if count < 100 { // ä½äº100ä¸ªæ—¶è¡¥å……
        p.Initialize()
    }
}

func main() {
    // ç”Ÿæˆåœ°å€ç¤ºä¾‹
    address, privKey, pubKey, err := GenerateEthereumAddress()
    if err != nil {
        fmt.Println("ç”Ÿæˆå¤±è´¥:", err)
        return
    }
    
    fmt.Println("åœ°å€:", address)
    fmt.Println("ç§é’¥:", privKey)
    fmt.Println("å…¬é’¥:", pubKey)
    
    // éªŒè¯ï¼šä»ç§é’¥æ¢å¤åœ°å€
    recoveredAddr, _ := GetAddressFromPrivateKey(privKey)
    fmt.Println("æ¢å¤çš„åœ°å€:", recoveredAddr)
    fmt.Println("åœ°å€ä¸€è‡´:", address == recoveredAddr)
}</code></pre>

                    <div class="tip-box warning">
                        <strong>âš ï¸ å®‰å…¨æ³¨æ„äº‹é¡¹</strong>
                        <ul>
                            <li>ç§é’¥å¿…é¡»åŠ å¯†å­˜å‚¨ï¼ˆAES-256ï¼‰</li>
                            <li>ä½¿ç”¨ HSMï¼ˆç¡¬ä»¶å®‰å…¨æ¨¡å—ï¼‰ä¿æŠ¤çƒ­é’±åŒ…ç§é’¥</li>
                            <li>å†·é’±åŒ…ç§é’¥ç¦»çº¿ä¿ç®¡</li>
                            <li>å®šæœŸå®¡è®¡åœ°å€æ± </li>
                        </ul>
                    </div>
                </div>

                <div id="deposit-watch">
                    <h3>4.2 ç›‘å¬é“¾ä¸Šå……å€¼ <span class="tag tag-required">å¿…è€ƒ</span></h3>
                    
                    <div class="tip-box info">
                        <strong>ğŸ’¡ é¢è¯•é—®é¢˜</strong>
                        å¦‚ä½•å®ç°å……å€¼ç›‘å¬ï¼Ÿéœ€è¦æ³¨æ„å“ªäº›é—®é¢˜ï¼Ÿ
                    </div>

                    <h4>ä¸¤ç§ç›‘å¬æ–¹å¼ï¼š</h4>
                    <table>
                        <tr>
                            <th>æ–¹å¼</th>
                            <th>åŸç†</th>
                            <th>ä¼˜ç‚¹</th>
                            <th>ç¼ºç‚¹</th>
                        </tr>
                        <tr>
                            <td>è®¢é˜…æ–°åŒºå—</td>
                            <td>WebSocket è®¢é˜…</td>
                            <td>å®æ—¶æ€§å¥½</td>
                            <td>ä¾èµ–è¿æ¥ç¨³å®š</td>
                        </tr>
                        <tr>
                            <td>è½®è¯¢åŒºå—</td>
                            <td>å®šæ—¶æŸ¥è¯¢æœ€æ–°åŒºå—</td>
                            <td>ç¨³å®šå¯é </td>
                            <td>æœ‰å»¶è¿Ÿ</td>
                        </tr>
                    </table>

                    <div class="code-header">
                        <span>deposit_watcher.go</span>
                        <button class="copy-btn" onclick="copyCode(this)">å¤åˆ¶</button>
                    </div>
                    <pre><code class="language-go">package main

import (
    "context"
    "fmt"
    "log"
    "math/big"
    
    "github.com/ethereum/go-ethereum"
    "github.com/ethereum/go-ethereum/common"
    "github.com/ethereum/go-ethereum/core/types"
    "github.com/ethereum/go-ethereum/ethclient"
)

// å……å€¼ç›‘å¬å™¨
type DepositWatcher struct {
    client         *ethclient.Client
    watchAddresses map[common.Address]string // åœ°å€ -> ç”¨æˆ·ID
    db             *sql.DB
    confirmations  int // ç¡®è®¤æ•°
}

func NewDepositWatcher(rpcURL string, db *sql.DB) (*DepositWatcher, error) {
    client, err := ethclient.Dial(rpcURL)
    if err != nil {
        return nil, err
    }
    
    watcher := &DepositWatcher{
        client:         client,
        watchAddresses: make(map[common.Address]string),
        db:             db,
        confirmations:  12, // ç­‰å¾…12ä¸ªåŒºå—ç¡®è®¤
    }
    
    // ä»æ•°æ®åº“åŠ è½½ç›‘å¬åœ°å€
    watcher.loadWatchAddresses()
    
    return watcher, nil
}

// åŠ è½½ç›‘å¬åœ°å€
func (w *DepositWatcher) loadWatchAddresses() error {
    rows, err := w.db.Query(`
        SELECT address, user_id 
        FROM user_addresses 
        WHERE currency = 'ETH'
    `)
    if err != nil {
        return err
    }
    defer rows.Close()
    
    for rows.Next() {
        var address, userID string
        rows.Scan(&address, &userID)
        w.watchAddresses[common.HexToAddress(address)] = userID
    }
    
    return nil
}

// æ–¹å¼1ï¼šè®¢é˜…æ–°åŒºå—ï¼ˆæ¨èï¼‰
func (w *DepositWatcher) WatchBlocksSubscribe(ctx context.Context) error {
    headers := make(chan *types.Header)
    
    sub, err := w.client.SubscribeNewHead(ctx, headers)
    if err != nil {
        return err
    }
    defer sub.Unsubscribe()
    
    fmt.Println("å¼€å§‹ç›‘å¬æ–°åŒºå—...")
    
    for {
        select {
        case err := <-sub.Err():
            log.Printf("è®¢é˜…é”™è¯¯: %v", err)
            return err
            
        case header := <-headers:
            // è·å–åŒºå—è¯¦æƒ…
            block, err := w.client.BlockByNumber(ctx, header.Number)
            if err != nil {
                log.Printf("è·å–åŒºå—å¤±è´¥: %v", err)
                continue
            }
            
            // æ£€æŸ¥åŒºå—ä¸­çš„äº¤æ˜“
            w.checkBlockTransactions(ctx, block)
        }
    }
}

// æ–¹å¼2ï¼šè½®è¯¢åŒºå—ï¼ˆæ›´ç¨³å®šï¼‰
func (w *DepositWatcher) WatchBlocksPoll(ctx context.Context) error {
    // è·å–èµ·å§‹åŒºå—
    lastBlock, _ := w.getLastProcessedBlock()
    
    ticker := time.NewTicker(3 * time.Second) // æ¯3ç§’æ£€æŸ¥ä¸€æ¬¡
    defer ticker.Stop()
    
    for {
        select {
        case <-ctx.Done():
            return ctx.Err()
            
        case <-ticker.C:
            // è·å–æœ€æ–°åŒºå—å·
            latestBlock, err := w.client.BlockNumber(ctx)
            if err != nil {
                log.Printf("è·å–æœ€æ–°åŒºå—å¤±è´¥: %v", err)
                continue
            }
            
            // å¤„ç†æ–°åŒºå—
            for blockNum := lastBlock + 1; blockNum <= latestBlock; blockNum++ {
                block, err := w.client.BlockByNumber(ctx, big.NewInt(int64(blockNum)))
                if err != nil {
                    log.Printf("è·å–åŒºå— %d å¤±è´¥: %v", blockNum, err)
                    continue
                }
                
                w.checkBlockTransactions(ctx, block)
                lastBlock = blockNum
                w.saveLastProcessedBlock(blockNum)
            }
        }
    }
}

// æ£€æŸ¥åŒºå—ä¸­çš„äº¤æ˜“
func (w *DepositWatcher) checkBlockTransactions(ctx context.Context, block *types.Block) {
    for _, tx := range block.Transactions() {
        // æ£€æŸ¥æ¥æ”¶åœ°å€æ˜¯å¦åœ¨ç›‘å¬åˆ—è¡¨ä¸­
        if tx.To() == nil {
            continue // åˆçº¦åˆ›å»ºäº¤æ˜“
        }
        
        toAddress := *tx.To()
        userID, exists := w.watchAddresses[toAddress]
        if !exists {
            continue
        }
        
        // æ£€æŸ¥äº¤æ˜“çŠ¶æ€
        receipt, err := w.client.TransactionReceipt(ctx, tx.Hash())
        if err != nil {
            log.Printf("è·å–äº¤æ˜“æ”¶æ®å¤±è´¥: %v", err)
            continue
        }
        
        if receipt.Status != 1 {
            continue // äº¤æ˜“å¤±è´¥
        }
        
        // æ£€æŸ¥ç¡®è®¤æ•°
        currentBlock, _ := w.client.BlockNumber(ctx)
        confirmations := currentBlock - block.Number().Uint64()
        
        if confirmations >= uint64(w.confirmations) {
            // å¤„ç†å……å€¼
            w.handleDeposit(userID, tx, block.Number().Uint64())
        } else {
            // è®°å½•å¾…ç¡®è®¤çš„å……å€¼
            w.recordPendingDeposit(userID, tx, block.Number().Uint64())
        }
    }
}

// å¤„ç†å……å€¼
func (w *DepositWatcher) handleDeposit(userID string, tx *types.Transaction, blockNum uint64) {
    amount := new(big.Float).SetInt(tx.Value())
    amount = amount.Quo(amount, big.NewFloat(1e18)) // Wei è½¬ ETH
    
    amountFloat, _ := amount.Float64()
    
    // æ£€æŸ¥æ˜¯å¦å·²å¤„ç†
    var count int
    w.db.QueryRow(`
        SELECT COUNT(*) FROM deposits 
        WHERE tx_hash = ?
    `, tx.Hash().Hex()).Scan(&count)
    
    if count > 0 {
        return // å·²å¤„ç†
    }
    
    // å¼€å¯äº‹åŠ¡
    tx2, _ := w.db.Begin()
    defer tx2.Rollback()
    
    // 1. è®°å½•å……å€¼
    _, err := tx2.Exec(`
        INSERT INTO deposits 
        (user_id, currency, amount, tx_hash, block_number, 
         confirmations, status, created_at)
        VALUES (?, 'ETH', ?, ?, ?, ?, 'confirmed', NOW())
    `, userID, amountFloat, tx.Hash().Hex(), blockNum, w.confirmations)
    
    if err != nil {
        log.Printf("è®°å½•å……å€¼å¤±è´¥: %v", err)
        return
    }
    
    // 2. å¢åŠ ç”¨æˆ·ä½™é¢
    _, err = tx2.Exec(`
        UPDATE accounts 
        SET available = available + ?
        WHERE user_id = ? AND currency = 'ETH'
    `, amountFloat, userID)
    
    if err != nil {
        log.Printf("å¢åŠ ä½™é¢å¤±è´¥: %v", err)
        return
    }
    
    // 3. è®°å½•æµæ°´
    _, err = tx2.Exec(`
        INSERT INTO transactions 
        (user_id, currency, type, amount, ref_id, created_at)
        VALUES (?, 'ETH', 'DEPOSIT', ?, ?, NOW())
    `, userID, amountFloat, tx.Hash().Hex())
    
    tx2.Commit()
    
    fmt.Printf("å……å€¼åˆ°è´¦ï¼šç”¨æˆ·=%s, é‡‘é¢=%.8f ETH, äº¤æ˜“=%s\n",
        userID, amountFloat, tx.Hash().Hex())
}

// è®°å½•å¾…ç¡®è®¤çš„å……å€¼
func (w *DepositWatcher) recordPendingDeposit(userID string, tx *types.Transaction, blockNum uint64) {
    // ç±»ä¼¼ handleDepositï¼Œä½† status = 'pending'
    // åå°ä»»åŠ¡ä¼šå®šæœŸæ£€æŸ¥ pending çš„å……å€¼æ˜¯å¦å·²è¾¾åˆ°ç¡®è®¤æ•°
}

func main() {
    db, _ := sql.Open("mysql", "user:pass@tcp(localhost:3306)/exchange")
    
    watcher, err := NewDepositWatcher("https://mainnet.infura.io/v3/YOUR_KEY", db)
    if err != nil {
        log.Fatal(err)
    }
    
    ctx := context.Background()
    
    // ä½¿ç”¨è½®è¯¢æ–¹å¼ï¼ˆæ›´ç¨³å®šï¼‰
    if err := watcher.WatchBlocksPoll(ctx); err != nil {
        log.Fatal(err)
    }
}</code></pre>

                    <div class="tip-box warning">
                        <strong>âš ï¸ é‡è¦æ³¨æ„äº‹é¡¹</strong>
                        <ul>
                            <li><strong>é‡å¤å¤„ç†</strong>ï¼šå¿…é¡»ç”¨äº¤æ˜“å“ˆå¸Œå»é‡</li>
                            <li><strong>ç¡®è®¤æ•°</strong>ï¼šETH å»ºè®® 12 ä¸ªåŒºå—ï¼ŒBTC å»ºè®® 6 ä¸ª</li>
                            <li><strong>é“¾é‡ç»„</strong>ï¼šç›‘æ§ reorgï¼Œå›æ»šå·²å¤„ç†çš„å……å€¼</li>
                            <li><strong>å¤±è´¥é‡è¯•</strong>ï¼šç½‘ç»œå¼‚å¸¸æ—¶è‡ªåŠ¨é‡è¯•</li>
                            <li><strong>å‘Šè­¦æœºåˆ¶</strong>ï¼šç›‘å¬æœåŠ¡å¼‚å¸¸ç«‹å³å‘Šè­¦</li>
                        </ul>
                    </div>

                    <h4>æ•°æ®åº“è¡¨è®¾è®¡ï¼š</h4>
                    <pre><code class="language-sql">-- å……å€¼è®°å½•è¡¨
CREATE TABLE deposits (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id VARCHAR(32) NOT NULL,
    currency VARCHAR(10) NOT NULL,
    amount DECIMAL(30, 8) NOT NULL,
    tx_hash VARCHAR(66) NOT NULL,
    block_number BIGINT NOT NULL,
    confirmations INT DEFAULT 0,
    status ENUM('pending', 'confirmed', 'failed') DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    confirmed_at TIMESTAMP NULL,
    UNIQUE KEY uk_tx_hash(tx_hash),
    INDEX idx_user_status(user_id, status),
    INDEX idx_block(block_number)
);</code></pre>
                </div>
            </section>

            <!-- ç¬¬5éƒ¨åˆ†ï¼šç³»ç»Ÿè®¾è®¡ -->
            <section class="section" id="section5">
                <h2>5. ç³»ç»Ÿè®¾è®¡å¤§é¢˜</h2>
                
                <div id="trading-system">
                    <h3>5.1 è®¾è®¡ä¸€ä¸ªç°è´§äº¤æ˜“ç³»ç»Ÿ <span class="tag tag-required">å¿…è€ƒ</span></h3>
                    
                    <h4>æ¶æ„è®¾è®¡ï¼š</h4>
                    <div class="architecture-diagram">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ç”¨æˆ·ç«¯     â”‚
â”‚ Web/App/API â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         API Gateway (é™æµ/é‰´æƒ)           â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”œâ”€â”€â”€â”€â”€â–º ã€äº¤æ˜“æœåŠ¡ã€‘è®¢å•ç®¡ç†ã€æ’®åˆå¼•æ“
       â”œâ”€â”€â”€â”€â”€â–º ã€èµ„äº§æœåŠ¡ã€‘ä½™é¢ç®¡ç†ã€å……æ
       â”œâ”€â”€â”€â”€â”€â–º ã€è¡Œæƒ…æœåŠ¡ã€‘Kçº¿ã€æ·±åº¦ã€å®æ—¶ä»·æ ¼
       â”œâ”€â”€â”€â”€â”€â–º ã€ç”¨æˆ·æœåŠ¡ã€‘æ³¨å†Œã€KYCã€API Key
       â””â”€â”€â”€â”€â”€â–º ã€é£æ§æœåŠ¡ã€‘åæ´—é’±ã€å¼‚å¸¸æ£€æµ‹
              â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
       â”‚   æ¶ˆæ¯é˜Ÿåˆ—   â”‚
       â”‚   (Kafka)    â”‚
       â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
              â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
       â”‚   æ•°æ®åº“     â”‚
       â”‚  MySQL é›†ç¾¤  â”‚
       â”‚ + Redis ç¼“å­˜ â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</div>

                    <h4>æ•°æ®åº“è®¾è®¡ï¼š</h4>
                    <pre><code class="language-sql">-- è®¢å•è¡¨ï¼ˆåˆ†åº“åˆ†è¡¨ï¼‰
CREATE TABLE orders (
    id BIGINT PRIMARY KEY,
    user_id VARCHAR(32) NOT NULL,
    symbol VARCHAR(20) NOT NULL,
    side ENUM('BUY', 'SELL'),
    type ENUM('LIMIT', 'MARKET'),
    price DECIMAL(20, 8),
    quantity DECIMAL(20, 8),
    filled DECIMAL(20, 8),
    status ENUM('pending', 'filled', 'partial', 'cancelled'),
    created_at TIMESTAMP,
    updated_at TIMESTAMP,
    INDEX idx_user_symbol(user_id, symbol)
) PARTITION BY RANGE(YEAR(created_at));

-- è´¦æˆ·è¡¨
CREATE TABLE accounts (
    user_id VARCHAR(32) PRIMARY KEY,
    currency VARCHAR(10) NOT NULL,
    available DECIMAL(30, 8) DEFAULT 0,
    frozen DECIMAL(30, 8) DEFAULT 0,
    updated_at TIMESTAMP,
    UNIQUE KEY uk_user_currency(user_id, currency)
);</code></pre>

                    <h4>æŠ€æœ¯é€‰å‹ï¼š</h4>
                    <table>
                        <tr>
                            <th>ç»„ä»¶</th>
                            <th>æŠ€æœ¯</th>
                            <th>ç”¨é€”</th>
                        </tr>
                        <tr>
                            <td>API Gateway</td>
                            <td>Kong / Nginx</td>
                            <td>é™æµã€é‰´æƒã€è·¯ç”±</td>
                        </tr>
                        <tr>
                            <td>æ’®åˆå¼•æ“</td>
                            <td>Go + å†…å­˜</td>
                            <td>é«˜æ€§èƒ½æ’®åˆ</td>
                        </tr>
                        <tr>
                            <td>æ•°æ®åº“</td>
                            <td>MySQL</td>
                            <td>è®¢å•ã€è´¦æˆ·æŒä¹…åŒ–</td>
                        </tr>
                        <tr>
                            <td>ç¼“å­˜</td>
                            <td>Redis</td>
                            <td>è®¢å•ç°¿ã€ç”¨æˆ·ä¼šè¯</td>
                        </tr>
                        <tr>
                            <td>æ¶ˆæ¯é˜Ÿåˆ—</td>
                            <td>Kafka</td>
                            <td>æˆäº¤æ¨é€ã€å¼‚æ­¥å¤„ç†</td>
                        </tr>
                        <tr>
                            <td>WebSocket</td>
                            <td>Gorilla</td>
                            <td>å®æ—¶è¡Œæƒ…æ¨é€</td>
                        </tr>
                    </table>
                </div>

                <div id="deposit-withdraw">
                    <h3>5.2 è®¾è®¡å……å€¼æç°ç³»ç»Ÿ <span class="tag tag-required">å¿…è€ƒ</span></h3>
                    
                    <div class="tip-box info">
                        <strong>ğŸ’¡ é¢è¯•é—®é¢˜</strong>
                        è®¾è®¡ä¸€ä¸ªå®‰å…¨å¯é çš„å……æç³»ç»Ÿï¼Œéœ€è¦è€ƒè™‘å“ªäº›é—®é¢˜ï¼Ÿ
                    </div>

                    <h4>ç³»ç»Ÿæ¶æ„ï¼š</h4>
                    <div class="architecture-diagram">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           å……å€¼æç°ç³»ç»Ÿæ¶æ„                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ã€å……å€¼æµç¨‹ã€‘
ç”¨æˆ·è½¬è´¦ â†’ é“¾ä¸Šç›‘å¬ â†’ ç­‰å¾…ç¡®è®¤ â†’ å…¥è´¦
    â”‚           â”‚          â”‚          â”‚
    â”‚           â”‚          â”‚          â””â”€â†’ å¢åŠ ä½™é¢
    â”‚           â”‚          â””â”€â†’ 12ä¸ªåŒºå—
    â”‚           â””â”€â†’ DepositWatcher
    â””â”€â†’ å‘é€åˆ°å……å€¼åœ°å€

ã€æç°æµç¨‹ã€‘
ç”¨æˆ·ç”³è¯· â†’ é£æ§æ£€æŸ¥ â†’ å†»ç»“ä½™é¢ â†’ æ„å»ºäº¤æ˜“
    â”‚           â”‚          â”‚          â”‚
    â”‚           â”‚          â”‚          â””â”€â†’ ç­¾åå¹¿æ’­
    â”‚           â”‚          â””â”€â†’ æ‰£é™¤å¯ç”¨
    â”‚           â””â”€â†’ é™é¢/ç™½åå•/å¼‚å¸¸æ£€æµ‹
    â””â”€â†’ æäº¤æç°è¯·æ±‚

ã€é’±åŒ…æ¶æ„ã€‘
çƒ­é’±åŒ…ï¼ˆ5%èµ„äº§ï¼‰â†’ å¤„ç†æ—¥å¸¸æç°
    â””â”€â†’ å¤šé‡ç­¾åï¼ˆ2/3ï¼‰
    
å†·é’±åŒ…ï¼ˆ95%èµ„äº§ï¼‰â†’ ç¦»çº¿ä¿ç®¡
    â””â”€â†’ äººå·¥è½¬è´¦è¡¥å……çƒ­é’±åŒ…</div>

                    <h4>å®Œæ•´å®ç°ï¼š</h4>
                    <div class="code-header">
                        <span>withdraw_service.go</span>
                        <button class="copy-btn" onclick="copyCode(this)">å¤åˆ¶</button>
                    </div>
                    <pre><code class="language-go">package main

import (
    "context"
    "errors"
    "math/big"
    
    "github.com/ethereum/go-ethereum/core/types"
    "github.com/ethereum/go-ethereum/ethclient"
)

// æç°æœåŠ¡
type WithdrawService struct {
    client       *ethclient.Client
    db           *sql.DB
    assetService *AssetService
    riskService  *RiskService
    signer       *TransactionSigner
}

// æç°è¯·æ±‚
type WithdrawRequest struct {
    UserID    string
    Currency  string
    ToAddress string
    Amount    float64
    IPAddress string
    UserAgent string
}

// 1. ç”¨æˆ·ç”³è¯·æç°
func (s *WithdrawService) RequestWithdraw(req *WithdrawRequest) (string, error) {
    // 1. åŸºç¡€éªŒè¯
    if err := s.validateRequest(req); err != nil {
        return "", err
    }
    
    // 2. é£æ§æ£€æŸ¥
    if err := s.riskService.CheckWithdraw(req); err != nil {
        return "", fmt.Errorf("é£æ§æ‹’ç»: %w", err)
    }
    
    // 3. æ£€æŸ¥ä½™é¢
    balance := s.assetService.GetBalance(req.UserID, req.Currency)
    if balance.Available < req.Amount {
        return "", errors.New("ä½™é¢ä¸è¶³")
    }
    
    // 4. å†»ç»“ä½™é¢
    if err := s.assetService.Freeze(req.UserID, req.Currency, req.Amount); err != nil {
        return "", err
    }
    
    // 5. åˆ›å»ºæç°è®°å½•
    withdrawID, err := s.createWithdrawRecord(req)
    if err != nil {
        // å›æ»šå†»ç»“
        s.assetService.Unfreeze(req.UserID, req.Currency, req.Amount)
        return "", err
    }
    
    // 6. å¼‚æ­¥å¤„ç†æç°ï¼ˆé¿å…é˜»å¡ï¼‰
    go s.processWithdraw(withdrawID)
    
    return withdrawID, nil
}

// åˆ›å»ºæç°è®°å½•
func (s *WithdrawService) createWithdrawRecord(req *WithdrawRequest) (string, error) {
    withdrawID := generateWithdrawID()
    
    _, err := s.db.Exec(`
        INSERT INTO withdraws 
        (id, user_id, currency, to_address, amount, fee, 
         status, ip_address, created_at)
        VALUES (?, ?, ?, ?, ?, ?, 'pending', ?, NOW())
    `, withdrawID, req.UserID, req.Currency, req.ToAddress, 
       req.Amount, calculateFee(req.Amount), req.IPAddress)
    
    return withdrawID, err
}

// 2. å¤„ç†æç°ï¼ˆåå°ä»»åŠ¡ï¼‰
func (s *WithdrawService) processWithdraw(withdrawID string) {
    // è·å–æç°ä¿¡æ¯
    withdraw, err := s.getWithdraw(withdrawID)
    if err != nil {
        log.Printf("è·å–æç°å¤±è´¥: %v", err)
        return
    }
    
    // å¤§é¢æç°éœ€è¦äººå·¥å®¡æ ¸
    if withdraw.Amount > 10000 { // å‡è®¾è¶…è¿‡1ä¸‡éœ€è¦å®¡æ ¸
        s.updateStatus(withdrawID, "pending_approval")
        s.notifyAdmin(withdraw)
        return
    }
    
    // å°é¢æç°è‡ªåŠ¨å¤„ç†
    s.executeWithdraw(withdraw)
}

// 3. æ‰§è¡Œæç°ï¼ˆæ„å»ºå’Œå¹¿æ’­äº¤æ˜“ï¼‰
func (s *WithdrawService) executeWithdraw(withdraw *Withdraw) error {
    ctx := context.Background()
    
    // 1. è·å–çƒ­é’±åŒ…åœ°å€
    hotWallet := s.getHotWallet(withdraw.Currency)
    
    // 2. æ„å»ºäº¤æ˜“
    tx, err := s.buildTransaction(ctx, withdraw, hotWallet)
    if err != nil {
        s.markWithdrawFailed(withdraw.ID, err.Error())
        return err
    }
    
    // 3. ç­¾åäº¤æ˜“ï¼ˆå¤šé‡ç­¾åï¼‰
    signedTx, err := s.signer.SignWithMultiSig(tx, hotWallet)
    if err != nil {
        s.markWithdrawFailed(withdraw.ID, err.Error())
        return err
    }
    
    // 4. å¹¿æ’­äº¤æ˜“
    err = s.client.SendTransaction(ctx, signedTx)
    if err != nil {
        s.markWithdrawFailed(withdraw.ID, err.Error())
        return err
    }
    
    // 5. æ›´æ–°çŠ¶æ€
    s.updateWithdraw(withdraw.ID, signedTx.Hash().Hex(), "processing")
    
    // 6. ç›‘å¬äº¤æ˜“ç¡®è®¤
    go s.monitorWithdrawConfirmation(withdraw.ID, signedTx.Hash().Hex())
    
    return nil
}

// æ„å»ºäº¤æ˜“
func (s *WithdrawService) buildTransaction(
    ctx context.Context,
    withdraw *Withdraw,
    hotWallet *Wallet,
) (*types.Transaction, error) {
    
    // è·å– nonce
    nonce, err := s.client.PendingNonceAt(ctx, hotWallet.Address)
    if err != nil {
        return nil, err
    }
    
    // è·å– gas price
    gasPrice, err := s.client.SuggestGasPrice(ctx)
    if err != nil {
        return nil, err
    }
    
    // è®¡ç®—é‡‘é¢ï¼ˆWeiï¼‰
    value := new(big.Int)
    value.SetString(fmt.Sprintf("%.0f", withdraw.Amount*1e18), 10)
    
    // ä¼°ç®— gas limit
    gasLimit := uint64(21000) // ETH è½¬è´¦å›ºå®š 21000
    
    // æ„å»ºäº¤æ˜“
    toAddress := common.HexToAddress(withdraw.ToAddress)
    tx := types.NewTransaction(
        nonce,
        toAddress,
        value,
        gasLimit,
        gasPrice,
        nil,
    )
    
    return tx, nil
}

// 4. ç›‘å¬äº¤æ˜“ç¡®è®¤
func (s *WithdrawService) monitorWithdrawConfirmation(withdrawID, txHash string) {
    ctx := context.Background()
    ticker := time.NewTicker(10 * time.Second)
    defer ticker.Stop()
    
    for range ticker.C {
        receipt, err := s.client.TransactionReceipt(ctx, common.HexToHash(txHash))
        if err != nil {
            continue // äº¤æ˜“è¿˜æœªä¸Šé“¾
        }
        
        // æ£€æŸ¥äº¤æ˜“çŠ¶æ€
        if receipt.Status == 0 {
            // äº¤æ˜“å¤±è´¥
            s.updateStatus(withdrawID, "failed")
            s.handleFailedWithdraw(withdrawID)
            return
        }
        
        // æ£€æŸ¥ç¡®è®¤æ•°
        currentBlock, _ := s.client.BlockNumber(ctx)
        confirmations := currentBlock - receipt.BlockNumber.Uint64()
        
        if confirmations >= 12 {
            // äº¤æ˜“æˆåŠŸ
            s.completeWithdraw(withdrawID)
            return
        }
    }
}

// 5. å®Œæˆæç°
func (s *WithdrawService) completeWithdraw(withdrawID string) error {
    withdraw, _ := s.getWithdraw(withdrawID)
    
    tx, _ := s.db.Begin()
    defer tx.Rollback()
    
    // 1. æ‰£é™¤å†»ç»“ä½™é¢
    _, err := tx.Exec(`
        UPDATE accounts 
        SET frozen = frozen - ?
        WHERE user_id = ? AND currency = ?
    `, withdraw.Amount, withdraw.UserID, withdraw.Currency)
    
    if err != nil {
        return err
    }
    
    // 2. æ›´æ–°æç°çŠ¶æ€
    _, err = tx.Exec(`
        UPDATE withdraws 
        SET status = 'completed', completed_at = NOW()
        WHERE id = ?
    `, withdrawID)
    
    if err != nil {
        return err
    }
    
    // 3. è®°å½•æµæ°´
    _, err = tx.Exec(`
        INSERT INTO transactions 
        (user_id, currency, type, amount, ref_id, created_at)
        VALUES (?, ?, 'WITHDRAW', ?, ?, NOW())
    `, withdraw.UserID, withdraw.Currency, -withdraw.Amount, withdrawID)
    
    tx.Commit()
    
    log.Printf("æç°å®Œæˆï¼šç”¨æˆ·=%s, é‡‘é¢=%.8f %s",
        withdraw.UserID, withdraw.Amount, withdraw.Currency)
    
    return nil
}

// å¤„ç†å¤±è´¥çš„æç°
func (s *WithdrawService) handleFailedWithdraw(withdrawID string) {
    withdraw, _ := s.getWithdraw(withdrawID)
    
    // è§£å†»ä½™é¢
    s.assetService.Unfreeze(withdraw.UserID, withdraw.Currency, withdraw.Amount)
    
    // é€šçŸ¥ç”¨æˆ·
    s.notifyUser(withdraw.UserID, "æç°å¤±è´¥ï¼Œä½™é¢å·²é€€å›")
}

// é£æ§æœåŠ¡
type RiskService struct {
    db *sql.DB
}

// é£æ§æ£€æŸ¥
func (r *RiskService) CheckWithdraw(req *WithdrawRequest) error {
    // 1. æ£€æŸ¥åœ°å€ç™½åå•
    if !r.isWhitelisted(req.UserID, req.ToAddress) {
        return errors.New("åœ°å€æœªåœ¨ç™½åå•ä¸­")
    }
    
    // 2. æ£€æŸ¥å•ç¬”é™é¢
    if req.Amount > 100 { // å‡è®¾å•ç¬”é™é¢100
        return errors.New("è¶…è¿‡å•ç¬”é™é¢")
    }
    
    // 3. æ£€æŸ¥æ—¥ç´¯è®¡é™é¢
    dailyTotal := r.getDailyWithdrawTotal(req.UserID, req.Currency)
    if dailyTotal+req.Amount > 1000 { // å‡è®¾æ—¥é™é¢1000
        return errors.New("è¶…è¿‡æ—¥ç´¯è®¡é™é¢")
    }
    
    // 4. æ£€æŸ¥å¼‚å¸¸è¡Œä¸º
    if r.isAbnormalBehavior(req) {
        return errors.New("æ£€æµ‹åˆ°å¼‚å¸¸è¡Œä¸º")
    }
    
    return nil
}

// å¼‚å¸¸è¡Œä¸ºæ£€æµ‹
func (r *RiskService) isAbnormalBehavior(req *WithdrawRequest) bool {
    // 1. IP åœ°å€çªå˜
    lastIP := r.getLastLoginIP(req.UserID)
    if lastIP != "" && lastIP != req.IPAddress {
        // IP å˜åŒ–ï¼Œå¢åŠ é£é™©è¯„åˆ†
    }
    
    // 2. çŸ­æ—¶é—´å†…å¤šæ¬¡æç°
    recentCount := r.getRecentWithdrawCount(req.UserID, 1*time.Hour)
    if recentCount > 5 {
        return true
    }
    
    // 3. æç°åˆ°æ–°åœ°å€
    if !r.hasWithdrawnToAddress(req.UserID, req.ToAddress) {
        // ç¬¬ä¸€æ¬¡æç°åˆ°è¿™ä¸ªåœ°å€ï¼Œéœ€è¦é¢å¤–éªŒè¯
    }
    
    return false
}</code></pre>

                    <h4>å®‰å…¨æªæ–½ï¼š</h4>
                    <table>
                        <tr>
                            <th>å±‚é¢</th>
                            <th>æªæ–½</th>
                            <th>è¯´æ˜</th>
                        </tr>
                        <tr>
                            <td>é’±åŒ…</td>
                            <td>çƒ­å†·åˆ†ç¦»</td>
                            <td>95%èµ„äº§å­˜å†·é’±åŒ…</td>
                        </tr>
                        <tr>
                            <td>ç­¾å</td>
                            <td>å¤šé‡ç­¾å</td>
                            <td>éœ€è¦2/3å¯†é’¥ç­¾å</td>
                        </tr>
                        <tr>
                            <td>é£æ§</td>
                            <td>é™é¢+ç™½åå•</td>
                            <td>å•ç¬”/æ—¥ç´¯è®¡é™é¢</td>
                        </tr>
                        <tr>
                            <td>å®¡æ ¸</td>
                            <td>äººå·¥å¤æ ¸</td>
                            <td>å¤§é¢æç°äººå·¥å®¡æ ¸</td>
                        </tr>
                        <tr>
                            <td>ç›‘æ§</td>
                            <td>å®æ—¶å‘Šè­¦</td>
                            <td>å¼‚å¸¸ç«‹å³é€šçŸ¥</td>
                        </tr>
                    </table>

                    <div class="tip-box warning">
                        <strong>âš ï¸ å…³é”®é£é™©ç‚¹</strong>
                        <ul>
                            <li><strong>ç§é’¥æ³„éœ²</strong>ï¼šä½¿ç”¨ HSMï¼Œå®šæœŸè½®æ¢</li>
                            <li><strong>é‡æ”¾æ”»å‡»</strong>ï¼šäº¤æ˜“å“ˆå¸Œå»é‡</li>
                            <li><strong>å†…éƒ¨ä½œæ¡ˆ</strong>ï¼šæ“ä½œæ—¥å¿—å®¡è®¡ï¼Œå¤šäººå®¡æ‰¹</li>
                            <li><strong>é’“é±¼æ”»å‡»</strong>ï¼šåœ°å€ç™½åå•æœºåˆ¶</li>
                            <li><strong>çƒ­é’±åŒ…è¢«ç›—</strong>ï¼šé™åˆ¶çƒ­é’±åŒ…ä½™é¢ï¼Œå®æ—¶ç›‘æ§</li>
                        </ul>
                    </div>
                </div>
            </section>

            <!-- ç¬¬6éƒ¨åˆ†ï¼šç®—æ³• -->
            <section class="section" id="section6">
                <h2>6. ç®—æ³•ä¸æ•°æ®ç»“æ„</h2>
                
                <div id="lru">
                    <h3>6.1 LRU Cache <span class="tag tag-required">å¿…è€ƒ</span></h3>
                    
                    <div class="tip-box info">
                        <strong>ğŸ’¡ æ ¸å¿ƒæ€æƒ³</strong>
                        å“ˆå¸Œè¡¨ + åŒå‘é“¾è¡¨ï¼Œå®ç° O(1) çš„ Get å’Œ Put
                    </div>

                    <div class="code-header">
                        <span>lru_cache.go</span>
                        <button class="copy-btn" onclick="copyCode(this)">å¤åˆ¶</button>
                    </div>
                    <pre><code class="language-go">type LRUCache struct {
    capacity int
    cache    map[interface{}]*list.Element
    list     *list.List
}

type entry struct {
    key   interface{}
    value interface{}
}

func (c *LRUCache) Get(key interface{}) (interface{}, bool) {
    if elem, exists := c.cache[key]; exists {
        // ç§»åˆ°é“¾è¡¨å¤´éƒ¨ï¼ˆæœ€è¿‘ä½¿ç”¨ï¼‰
        c.list.MoveToFront(elem)
        return elem.Value.(*entry).value, true
    }
    return nil, false
}

func (c *LRUCache) Put(key, value interface{}) {
    if elem, exists := c.cache[key]; exists {
        c.list.MoveToFront(elem)
        elem.Value.(*entry).value = value
        return
    }
    
    // æ–°å¢
    elem := c.list.PushFront(&entry{key, value})
    c.cache[key] = elem
    
    // è¶…è¿‡å®¹é‡ï¼Œåˆ é™¤æœ€ä¹…æœªä½¿ç”¨çš„
    if c.list.Len() > c.capacity {
        oldest := c.list.Back()
        if oldest != nil {
            c.list.Remove(oldest)
            delete(c.cache, oldest.Value.(*entry).key)
        }
    }
}</code></pre>

                    <h4>äº¤æ˜“æ‰€åº”ç”¨åœºæ™¯ï¼š</h4>
                    <ul>
                        <li>ç¼“å­˜ç”¨æˆ·çš„è®¢å•åˆ—è¡¨</li>
                        <li>ç¼“å­˜çƒ­é—¨äº¤æ˜“å¯¹çš„è®¢å•ç°¿</li>
                        <li>ç¼“å­˜ç”¨æˆ·çš„è´¦æˆ·ä¿¡æ¯</li>
                    </ul>
                </div>

                <div id="consistent-hash">
                    <h3>6.2 ä¸€è‡´æ€§Hashï¼ˆåˆ†å¸ƒå¼ç¼“å­˜ï¼‰<span class="tag tag-important">é‡è¦</span></h3>
                    
                    <div class="tip-box info">
                        <strong>ğŸ’¡ é¢è¯•é—®é¢˜</strong>
                        ä¸€è‡´æ€§Hashè§£å†³äº†ä»€ä¹ˆé—®é¢˜ï¼Ÿå¦‚ä½•å®ç°ï¼Ÿ
                    </div>

                    <h4>ä¸ºä»€ä¹ˆéœ€è¦ä¸€è‡´æ€§Hashï¼Ÿ</h4>
                    <p><strong>ä¼ ç»Ÿå–æ¨¡ç®—æ³•çš„é—®é¢˜ï¼š</strong></p>
                    <ul>
                        <li>èŠ‚ç‚¹æ•°é‡å˜åŒ–æ—¶ï¼Œå¤§é‡æ•°æ®éœ€è¦è¿ç§»</li>
                        <li>ä¾‹å¦‚ï¼š3ä¸ªèŠ‚ç‚¹æ‰©å®¹åˆ°4ä¸ªï¼Œ75%çš„æ•°æ®è¦é‡æ–°åˆ†é…</li>
                    </ul>

                    <p><strong>ä¸€è‡´æ€§Hashçš„ä¼˜åŠ¿ï¼š</strong></p>
                    <ul>
                        <li>èŠ‚ç‚¹å˜åŒ–æ—¶ï¼Œåªå½±å“ç›¸é‚»èŠ‚ç‚¹çš„æ•°æ®</li>
                        <li>æ•°æ®è¿ç§»é‡å¤§çº¦æ˜¯ 1/Nï¼ˆNä¸ºèŠ‚ç‚¹æ•°ï¼‰</li>
                        <li>è™šæ‹ŸèŠ‚ç‚¹ä¿è¯æ•°æ®åˆ†å¸ƒå‡åŒ€</li>
                    </ul>

                    <h4>å®Œæ•´å®ç°ï¼š</h4>
                    <div class="code-header">
                        <span>consistent_hash.go</span>
                        <button class="copy-btn" onclick="copyCode(this)">å¤åˆ¶</button>
                    </div>
                    <pre><code class="language-go">package main

import (
    "crypto/md5"
    "fmt"
    "sort"
    "strconv"
)

// ä¸€è‡´æ€§Hashç¯
type ConsistentHash struct {
    hashRing   []int            // æ’åºåçš„hashå€¼
    hashMap    map[int]string   // hash -> èŠ‚ç‚¹å
    nodes      map[string]bool  // èŠ‚ç‚¹é›†åˆ
    replicas   int              // è™šæ‹ŸèŠ‚ç‚¹æ•°
}

func NewConsistentHash(replicas int) *ConsistentHash {
    return &ConsistentHash{
        hashRing: []int{},
        hashMap:  make(map[int]string),
        nodes:    make(map[string]bool),
        replicas: replicas,
    }
}

// æ·»åŠ èŠ‚ç‚¹
func (ch *ConsistentHash) AddNode(node string) {
    if ch.nodes[node] {
        return
    }
    
    ch.nodes[node] = true
    
    // åˆ›å»ºè™šæ‹ŸèŠ‚ç‚¹
    for i := 0; i < ch.replicas; i++ {
        virtualNode := fmt.Sprintf("%s#%d", node, i)
        hash := ch.hash(virtualNode)
        ch.hashRing = append(ch.hashRing, hash)
        ch.hashMap[hash] = node
    }
    
    // ä¿æŒæ’åº
    sort.Ints(ch.hashRing)
}

// ç§»é™¤èŠ‚ç‚¹
func (ch *ConsistentHash) RemoveNode(node string) {
    if !ch.nodes[node] {
        return
    }
    
    delete(ch.nodes, node)
    
    // ç§»é™¤è™šæ‹ŸèŠ‚ç‚¹
    newRing := []int{}
    for _, hash := range ch.hashRing {
        if ch.hashMap[hash] != node {
            newRing = append(newRing, hash)
        } else {
            delete(ch.hashMap, hash)
        }
    }
    ch.hashRing = newRing
}

// è·å–keyå¯¹åº”çš„èŠ‚ç‚¹
func (ch *ConsistentHash) GetNode(key string) string {
    if len(ch.hashRing) == 0 {
        return ""
    }
    
    hash := ch.hash(key)
    
    // äºŒåˆ†æŸ¥æ‰¾ç¬¬ä¸€ä¸ª >= hash çš„èŠ‚ç‚¹
    idx := sort.Search(len(ch.hashRing), func(i int) bool {
        return ch.hashRing[i] >= hash
    })
    
    // å¦‚æœæ²¡æ‰¾åˆ°ï¼Œè¯´æ˜è¶…è¿‡äº†æœ€å¤§å€¼ï¼Œå–ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆç¯å½¢ï¼‰
    if idx == len(ch.hashRing) {
        idx = 0
    }
    
    return ch.hashMap[ch.hashRing[idx]]
}

// Hashå‡½æ•°
func (ch *ConsistentHash) hash(key string) int {
    h := md5.Sum([]byte(key))
    // å–å‰4å­—èŠ‚ä½œä¸ºhashå€¼
    return int(h[0])<<24 | int(h[1])<<16 | int(h[2])<<8 | int(h[3])
}

// è·å–æ‰€æœ‰èŠ‚ç‚¹
func (ch *ConsistentHash) GetNodes() []string {
    nodes := []string{}
    for node := range ch.nodes {
        nodes = append(nodes, node)
    }
    return nodes
}

// æµ‹è¯•æ•°æ®åˆ†å¸ƒ
func TestConsistentHash() {
    ch := NewConsistentHash(150) // 150ä¸ªè™šæ‹ŸèŠ‚ç‚¹
    
    // æ·»åŠ 3ä¸ªRedisèŠ‚ç‚¹
    ch.AddNode("redis-1")
    ch.AddNode("redis-2")
    ch.AddNode("redis-3")
    
    // æµ‹è¯•10000ä¸ªkeyçš„åˆ†å¸ƒ
    distribution := make(map[string]int)
    
    for i := 0; i < 10000; i++ {
        key := "orderbook:" + strconv.Itoa(i)
        node := ch.GetNode(key)
        distribution[node]++
    }
    
    fmt.Println("=== åˆå§‹æ•°æ®åˆ†å¸ƒ ===")
    for node, count := range distribution {
        fmt.Printf("%s: %d (%.2f%%)\n", 
            node, count, float64(count)/100)
    }
    
    // æ·»åŠ ç¬¬4ä¸ªèŠ‚ç‚¹
    fmt.Println("\næ·»åŠ èŠ‚ç‚¹ redis-4...")
    ch.AddNode("redis-4")
    
    // ç»Ÿè®¡æ•°æ®è¿ç§»
    newDistribution := make(map[string]int)
    moved := 0
    
    for i := 0; i < 10000; i++ {
        key := "orderbook:" + strconv.Itoa(i)
        newNode := ch.GetNode(key)
        newDistribution[newNode]++
        
        // ç»Ÿè®¡è¿ç§»é‡
        oldNode := ""
        if i < 3333 {
            oldNode = "redis-1"
        } else if i < 6666 {
            oldNode = "redis-2"
        } else {
            oldNode = "redis-3"
        }
        
        if newNode != oldNode {
            moved++
        }
    }
    
    fmt.Println("\n=== æ–°å¢èŠ‚ç‚¹åæ•°æ®åˆ†å¸ƒ ===")
    for node, count := range newDistribution {
        fmt.Printf("%s: %d (%.2f%%)\n", 
            node, count, float64(count)/100)
    }
    
    fmt.Printf("\nè¿ç§»æ•°æ®é‡: %d (%.2f%%)\n", 
        moved, float64(moved)/100)
}

// äº¤æ˜“æ‰€åº”ç”¨ï¼šåˆ†å¸ƒå¼è®¢å•ç°¿ç¼“å­˜
type OrderBookCache struct {
    ch     *ConsistentHash
    redis  map[string]*RedisClient // èŠ‚ç‚¹å -> Rediså®¢æˆ·ç«¯
}

func NewOrderBookCache(redisNodes []string) *OrderBookCache {
    ch := NewConsistentHash(150)
    redis := make(map[string]*RedisClient)
    
    for _, node := range redisNodes {
        ch.AddNode(node)
        redis[node] = NewRedisClient(node)
    }
    
    return &OrderBookCache{
        ch:    ch,
        redis: redis,
    }
}

// è·å–è®¢å•ç°¿
func (c *OrderBookCache) GetOrderBook(symbol string) (*OrderBook, error) {
    node := c.ch.GetNode(symbol)
    client := c.redis[node]
    
    // ä»å¯¹åº”çš„RedisèŠ‚ç‚¹è·å–
    return client.Get("orderbook:" + symbol)
}

// è®¾ç½®è®¢å•ç°¿
func (c *OrderBookCache) SetOrderBook(symbol string, orderbook *OrderBook) error {
    node := c.ch.GetNode(symbol)
    client := c.redis[node]
    
    return client.Set("orderbook:"+symbol, orderbook)
}

// æ‰©å®¹ï¼šæ·»åŠ æ–°RedisèŠ‚ç‚¹
func (c *OrderBookCache) AddRedisNode(nodeName, nodeAddr string) {
    // 1. æ·»åŠ åˆ°Hashç¯
    c.ch.AddNode(nodeName)
    
    // 2. åˆ›å»ºRediså®¢æˆ·ç«¯
    c.redis[nodeName] = NewRedisClient(nodeAddr)
    
    // 3. è¿ç§»æ•°æ®ï¼ˆåå°ä»»åŠ¡ï¼‰
    go c.migrateData(nodeName)
}

// è¿ç§»æ•°æ®
func (c *OrderBookCache) migrateData(newNode string) {
    // éå†æ‰€æœ‰äº¤æ˜“å¯¹
    symbols := []string{"BTC/USDT", "ETH/USDT", "BNB/USDT"} // å®é™…ä»æ•°æ®åº“è·å–
    
    for _, symbol := range symbols {
        currentNode := c.ch.GetNode(symbol)
        
        // å¦‚æœè¿™ä¸ªkeyåº”è¯¥åœ¨æ–°èŠ‚ç‚¹ä¸Š
        if currentNode == newNode {
            // ä»æ—§èŠ‚ç‚¹è¯»å–æ•°æ®
            // å†™å…¥æ–°èŠ‚ç‚¹
            // åˆ é™¤æ—§èŠ‚ç‚¹æ•°æ®
        }
    }
}

func main() {
    TestConsistentHash()
    
    // äº¤æ˜“æ‰€åº”ç”¨ç¤ºä¾‹
    cache := NewOrderBookCache([]string{
        "redis-1:6379",
        "redis-2:6379",
        "redis-3:6379",
    })
    
    // è·å–BTC/USDTçš„è®¢å•ç°¿
    orderbook, _ := cache.GetOrderBook("BTC/USDT")
    fmt.Printf("BTC/USDT è®¢å•ç°¿åœ¨èŠ‚ç‚¹: %s\n", 
        cache.ch.GetNode("BTC/USDT"))
}</code></pre>

                    <h4>æ€§èƒ½å¯¹æ¯”ï¼š</h4>
                    <table>
                        <tr>
                            <th>æ–¹æ¡ˆ</th>
                            <th>èŠ‚ç‚¹å˜åŒ–æ—¶è¿ç§»é‡</th>
                            <th>æ•°æ®åˆ†å¸ƒ</th>
                            <th>å®ç°å¤æ‚åº¦</th>
                        </tr>
                        <tr>
                            <td>å–æ¨¡ç®—æ³•</td>
                            <td>75%ï¼ˆ3â†’4èŠ‚ç‚¹ï¼‰</td>
                            <td>å®Œå…¨å‡åŒ€</td>
                            <td>ç®€å•</td>
                        </tr>
                        <tr>
                            <td>ä¸€è‡´æ€§Hashï¼ˆæ— è™šæ‹ŸèŠ‚ç‚¹ï¼‰</td>
                            <td>25%</td>
                            <td>å¯èƒ½ä¸å‡åŒ€</td>
                            <td>ä¸­ç­‰</td>
                        </tr>
                        <tr>
                            <td>ä¸€è‡´æ€§Hashï¼ˆæœ‰è™šæ‹ŸèŠ‚ç‚¹ï¼‰</td>
                            <td>25%</td>
                            <td>å‡åŒ€</td>
                            <td>ç¨å¤æ‚</td>
                        </tr>
                    </table>

                    <h4>äº¤æ˜“æ‰€åº”ç”¨åœºæ™¯ï¼š</h4>
                    <ul>
                        <li><strong>è®¢å•ç°¿ç¼“å­˜</strong>ï¼šæŒ‰äº¤æ˜“å¯¹åˆ†å¸ƒåˆ°ä¸åŒRedisèŠ‚ç‚¹</li>
                        <li><strong>ç”¨æˆ·ä¼šè¯</strong>ï¼šæŒ‰ç”¨æˆ·IDåˆ†å¸ƒWebSocketè¿æ¥</li>
                        <li><strong>è¡Œæƒ…æ¨é€</strong>ï¼šè´Ÿè½½å‡è¡¡åˆ°å¤šä¸ªæ¨é€æœåŠ¡</li>
                        <li><strong>æ’®åˆå¼•æ“</strong>ï¼šä¸åŒäº¤æ˜“å¯¹è·¯ç”±åˆ°ä¸åŒæ’®åˆèŠ‚ç‚¹</li>
                    </ul>

                    <div class="tip-box success">
                        <strong>âœ… æœ€ä½³å®è·µ</strong>
                        <ul>
                            <li>è™šæ‹ŸèŠ‚ç‚¹æ•°é‡ï¼š150-200ä¸ªï¼Œå¹³è¡¡åˆ†å¸ƒå‡åŒ€æ€§å’Œå†…å­˜å ç”¨</li>
                            <li>Hashå‡½æ•°ï¼šMD5æˆ–MurmurHashï¼Œä¿è¯åˆ†å¸ƒå‡åŒ€</li>
                            <li>èŠ‚ç‚¹å˜åŒ–ï¼šä½¿ç”¨ç°åº¦å‘å¸ƒï¼Œé€æ­¥è¿ç§»æ•°æ®</li>
                            <li>ç›‘æ§å‘Šè­¦ï¼šå®æ—¶ç›‘æ§å„èŠ‚ç‚¹è´Ÿè½½ï¼Œé˜²æ­¢çƒ­ç‚¹</li>
                        </ul>
                    </div>
                </div>
            </section>

            <!-- é¢è¯•æ¨¡æ‹Ÿ -->
            <section class="section" id="interview">
                <h2>7. é¢è¯•æ¨¡æ‹Ÿå¯¹è¯</h2>
                
                <div class="tip-box info">
                    <strong>åœºæ™¯1ï¼šGMP è°ƒåº¦æ¨¡å‹</strong>
                    <p><strong>é¢è¯•å®˜</strong>ï¼šä½ åœ¨ç®€å†ä¸Šå†™äº†ç†Ÿæ‚‰ Go å¹¶å‘ï¼Œèƒ½è®²è®² GMP æ¨¡å‹å—ï¼Ÿ</p>
                    <p><strong>ä½ </strong>ï¼šå¥½çš„ã€‚Go çš„è°ƒåº¦å™¨é‡‡ç”¨ GMP æ¨¡å‹ã€‚G æ˜¯ Goroutineï¼Œä»£è¡¨ç”¨æˆ·æ€è½»é‡çº§çº¿ç¨‹ï¼›M æ˜¯ Machineï¼Œä»£è¡¨æ“ä½œç³»ç»Ÿçº¿ç¨‹ï¼›P æ˜¯ Processorï¼Œè´Ÿè´£è°ƒåº¦ G çš„æ‰§è¡Œã€‚</p>
                    <p>æ ¸å¿ƒæœºåˆ¶æ˜¯ï¼šæ¯ä¸ª P ç»´æŠ¤ä¸€ä¸ªæœ¬åœ° G é˜Ÿåˆ—ï¼ŒM éœ€è¦ç»‘å®š P æ‰èƒ½æ‰§è¡Œ Gã€‚å½“ P çš„æœ¬åœ°é˜Ÿåˆ—ä¸ºç©ºæ—¶ï¼Œä¼šä»å…¶ä»– P æˆ–å…¨å±€é˜Ÿåˆ—å·å– Gï¼Œè¿™å« Work Stealingã€‚</p>
                    <p>è¿™ç§è®¾è®¡çš„ä¼˜åŠ¿æ˜¯ï¼šå‡å°‘é”ç«äº‰ã€å……åˆ†åˆ©ç”¨å¤šæ ¸ã€æ”¯æŒæŠ¢å å¼è°ƒåº¦ã€‚</p>
                </div>

                <div class="tip-box success">
                    <strong>åœºæ™¯2ï¼šæ’®åˆå¼•æ“è®¾è®¡</strong>
                    <p><strong>é¢è¯•å®˜</strong>ï¼šå¦‚æœè®©ä½ å®ç°ä¸€ä¸ªäº¤æ˜“æ‰€çš„æ’®åˆå¼•æ“ï¼Œä½ ä¼šæ€ä¹ˆè®¾è®¡ï¼Ÿ</p>
                    <p><strong>ä½ </strong>ï¼šæˆ‘ä¼šè®¾è®¡ä¸€ä¸ªå†…å­˜æ’®åˆå¼•æ“ï¼Œæ ¸å¿ƒæ˜¯è®¢å•ç°¿ã€‚è®¢å•ç°¿ç”¨ä¸¤ä¸ª map å­˜å‚¨ä¹°å–ç›˜ï¼Œæ¯ä¸ªä»·æ ¼å¯¹åº”ä¸€ä¸ªé“¾è¡¨ã€‚</p>
                    <p>ä¹°å•æŒ‰ä»·æ ¼é™åºæ’åˆ—ï¼Œå–å•æŒ‰ä»·æ ¼å‡åºæ’åˆ—ã€‚æ’®åˆæ—¶éµå¾ªä»·æ ¼ä¼˜å…ˆã€æ—¶é—´ä¼˜å…ˆåŸåˆ™ã€‚</p>
                    <p>ä¸ºäº†ä¿è¯æ€§èƒ½ï¼Œæ’®åˆå¼•æ“åœ¨å†…å­˜ä¸­è¿è¡Œï¼Œé€šè¿‡å®šæ—¶å¿«ç…§å’Œ WAL æ—¥å¿—ä¿è¯æ•°æ®ä¸ä¸¢å¤±ã€‚</p>
                </div>

                <div class="tip-box warning">
                    <strong>åœºæ™¯3ï¼šä½™é¢ä¸€è‡´æ€§</strong>
                    <p><strong>é¢è¯•å®˜</strong>ï¼šå¦‚ä½•ä¿è¯èµ„äº§ç³»ç»Ÿçš„ä½™é¢ä¸€è‡´æ€§ï¼Ÿ</p>
                    <p><strong>ä½ </strong>ï¼šèµ„äº§ç³»ç»Ÿé‡‡ç”¨åŒè´¦æˆ·æ¨¡å‹ï¼šå¯ç”¨ä½™é¢ + å†»ç»“ä½™é¢ã€‚</p>
                    <p>æµç¨‹æ˜¯ï¼šä¸‹å•æ—¶å†»ç»“ï¼Œæˆäº¤æ—¶æ‰£é™¤å†»ç»“ï¼Œæ’¤å•æ—¶è§£å†»ã€‚æ¯ä¸€æ­¥éƒ½è®°å½•æµæ°´ã€‚</p>
                    <p>åœ¨æ•°æ®åº“å±‚é¢ä½¿ç”¨äº‹åŠ¡ä¿è¯åŸå­æ€§ï¼Œå®šæ—¶å¯¹è´¦æ£€æŸ¥å¯ç”¨+å†»ç»“æ˜¯å¦ç­‰äºæ€»èµ„äº§ã€‚</p>
                </div>
            </section>

            <!-- æ€»ç»“å»ºè®® -->
            <section class="section" id="summary">
                <h2>8. æ€»ç»“ä¸å­¦ä¹ å»ºè®®</h2>
                
                <h3>å¿…é¡»æŒæ¡çš„æ ¸å¿ƒçŸ¥è¯† âœ…</h3>
                <ol>
                    <li><strong>Go å¹¶å‘</strong>ï¼šGMP æ¨¡å‹ã€Channelã€Contextã€é”æœºåˆ¶</li>
                    <li><strong>æ’®åˆå¼•æ“</strong>ï¼šè®¢å•ç°¿è®¾è®¡ã€ä»·æ ¼ä¼˜å…ˆæ—¶é—´ä¼˜å…ˆ</li>
                    <li><strong>èµ„äº§ç³»ç»Ÿ</strong>ï¼šåŒè´¦æˆ·æ¨¡å‹ã€æµæ°´å¯¹è´¦</li>
                    <li><strong>é™æµ</strong>ï¼šä»¤ç‰Œæ¡¶ç®—æ³•</li>
                    <li><strong>åˆ†å¸ƒå¼ID</strong>ï¼šé›ªèŠ±ç®—æ³•</li>
                    <li><strong>åŒºå—é“¾</strong>ï¼šåœ°å€ç”Ÿæˆã€äº¤æ˜“ç›‘å¬</li>
                </ol>

                <h3>åŠ åˆ†é¡¹ â­</h3>
                <ul>
                    <li>GitHub ä¸Šçš„äº¤æ˜“æ‰€é¡¹ç›®å®æˆ˜</li>
                    <li>æ€§èƒ½ä¼˜åŒ–æ¡ˆä¾‹ï¼ˆpprofã€GC è°ƒä¼˜ï¼‰</li>
                    <li>çº¿ä¸Šäº‹æ•…å¤„ç†ç»éªŒ</li>
                    <li>å¼€æºè´¡çŒ®</li>
                </ul>

                <h3>12å‘¨å­¦ä¹ è·¯çº¿ ğŸ“…</h3>
                <table>
                    <tr>
                        <th>å‘¨æ¬¡</th>
                        <th>å­¦ä¹ å†…å®¹</th>
                        <th>äº§å‡º</th>
                    </tr>
                    <tr>
                        <td>1-2å‘¨</td>
                        <td>Go åŸºç¡€å¼ºåŒ–</td>
                        <td>æŒæ¡å¹¶å‘ã€æ¥å£ã€åå°„</td>
                    </tr>
                    <tr>
                        <td>3-4å‘¨</td>
                        <td>äº¤æ˜“æ‰€ä¸šåŠ¡å­¦ä¹ </td>
                        <td>ç†è§£æ’®åˆã€èµ„äº§ã€é£æ§</td>
                    </tr>
                    <tr>
                        <td>5-6å‘¨</td>
                        <td>ç³»ç»Ÿè®¾è®¡å­¦ä¹ </td>
                        <td>é˜…è¯» DDIAï¼Œç”»æ¶æ„å›¾</td>
                    </tr>
                    <tr>
                        <td>7-8å‘¨</td>
                        <td>é¡¹ç›®å®æˆ˜</td>
                        <td>å®ç°ç®€æ˜“äº¤æ˜“æ‰€</td>
                    </tr>
                    <tr>
                        <td>9-10å‘¨</td>
                        <td>ç®—æ³•åˆ·é¢˜</td>
                        <td>LeetCode å‰ 200 é¢˜</td>
                    </tr>
                    <tr>
                        <td>11-12å‘¨</td>
                        <td>æ¨¡æ‹Ÿé¢è¯•</td>
                        <td>å‡†å¤‡é¢è¯•è¯æœ¯</td>
                    </tr>
                </table>

                <div class="tip-box success">
                    <strong>ğŸ¯ æœ€åçš„å»ºè®®</strong>
                    <ul>
                        <li>æ¯ä¸ªçŸ¥è¯†ç‚¹éƒ½è¦æ‰‹å†™ä»£ç ï¼Œç†è§£åŸç†</li>
                        <li>å…³æ³¨ Gate.ioã€å¸å®‰ã€OKX çš„æŠ€æœ¯åšå®¢</li>
                        <li>å‚ä¸å¼€æºé¡¹ç›®ï¼Œç§¯ç´¯å®æˆ˜ç»éªŒ</li>
                        <li>å‡†å¤‡ 3-5 ä¸ªæŠ€æœ¯äº®ç‚¹æ•…äº‹</li>
                    </ul>
                </div>
            </section>
        </main>
    </div>

    <!-- å›åˆ°é¡¶éƒ¨æŒ‰é’® -->
    <div class="back-to-top" id="backToTop" onclick="scrollToTop()">
        â†‘
    </div>

    <script>
        // ä»£ç é«˜äº®
        document.addEventListener('DOMContentLoaded', (event) => {
            document.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightElement(block);
            });
        });

        // ç§»åŠ¨ç«¯èœå•æ§åˆ¶
        const menuToggle = document.getElementById('menuToggle');
        const sidebar = document.querySelector('.sidebar');
        const sidebarOverlay = document.getElementById('sidebarOverlay');

        function toggleMenu() {
            sidebar.classList.toggle('show');
            sidebarOverlay.classList.toggle('show');
            menuToggle.classList.toggle('active');
            
            // åˆ‡æ¢å›¾æ ‡
            if (sidebar.classList.contains('show')) {
                menuToggle.innerHTML = 'âœ•';
            } else {
                menuToggle.innerHTML = 'â˜°';
            }
        }

        menuToggle.addEventListener('click', toggleMenu);
        sidebarOverlay.addEventListener('click', toggleMenu);

        // ç‚¹å‡»ä¾§è¾¹æ é“¾æ¥åå…³é—­èœå•ï¼ˆç§»åŠ¨ç«¯ï¼‰
        document.querySelectorAll('.sidebar a').forEach(link => {
            link.addEventListener('click', () => {
                if (window.innerWidth <= 968) {
                    toggleMenu();
                }
            });
        });

        // å¤åˆ¶ä»£ç 
        function copyCode(btn) {
            const codeBlock = btn.parentElement.nextElementSibling.querySelector('code');
            const text = codeBlock.textContent;
            
            navigator.clipboard.writeText(text).then(() => {
                btn.textContent = 'å·²å¤åˆ¶!';
                setTimeout(() => {
                    btn.textContent = 'å¤åˆ¶';
                }, 2000);
            });
        }

        // å›åˆ°é¡¶éƒ¨
        window.addEventListener('scroll', () => {
            const btn = document.getElementById('backToTop');
            if (window.pageYOffset > 300) {
                btn.classList.add('show');
            } else {
                btn.classList.remove('show');
            }
        });

        function scrollToTop() {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }

        // å¹³æ»‘æ»šåŠ¨
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });

        // ç›‘å¬çª—å£å¤§å°å˜åŒ–
        window.addEventListener('resize', () => {
            if (window.innerWidth > 968) {
                // æ¡Œé¢ç«¯è‡ªåŠ¨æ˜¾ç¤ºä¾§è¾¹æ 
                sidebar.classList.remove('show');
                sidebarOverlay.classList.remove('show');
                menuToggle.classList.remove('active');
                menuToggle.innerHTML = 'â˜°';
            }
        });
    </script>
</body>
</html>